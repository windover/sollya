#NAME $EXTERNALPROC
#QUICK_DESCRIPTION binds an external code to a $SOLLYA procedure
#CALLING $COMMAND(<identifier>, <filename>, <argumenttype> §§->§$->$§§ <resulttype>)
#TYPE ($IDENTIFIER_TYPE, $STRING_TYPE, $TYPE_TYPE, $TYPE_TYPE) -> $VOID_TYPE
#PARAMETERS <identifier> represents the identifier the code is to be bound to
#PARAMETERS <filename> of type $STRING_TYPE represents the name of the object file where the code of procedure can be found
#PARAMETERS <argumenttype> represents a definition of the types of the arguments of the $SOLLYA procedure and the external code
#PARAMETERS <resulttype> represents a definition of the result type of the external code

#DESCRIPTION 
$COMMAND allows for binding the $SOLLYA identifier
<identifier> to an external code.  After this binding, when $SOLLYA
encounters <identifier> applied to a list of actual parameters, it
will evaluate these parameters and call the external code with these
parameters. If the external code indicated success, it will receive
the result produced by the external code, transform it to $SOLLYA's
internal representation and return it.
§§ § §§
In order to allow correct evaluation and typing of the data in
parameter and in result to be passed to and received from the external
code, $COMMAND has a third parameter <argumenttype> §§->§$->$§§ <resulttype>.
Both <argumenttype> and <resulttype> are one of $VOID, $CONSTANT,
$FUNCTION, $RANGE, $INTEGER, $STRING, $BOOLEAN, $LISTOF $CONSTANT, $LISTOF $FUNCTION, 
$LISTOF $RANGE, $LISTOF $INTEGER, $LISTOF $STRING, $LISTOF $BOOLEAN.
§§ § §§
If upon a usage of a procedure bound to an external procedure the type
of the actual parameters given or its number is not correct, $SOLLYA
produces a type error. An external function not applied to arguments
represents itself and prints out with its argument and result types.
§§ § §§
The external function is supposed to return an integer indicating
success.  It returns its result depending on its $SOLLYA result type
as follows. Here, the external procedure is assumed to be implemented
as a C function.
§§ § §§
If the $SOLLYA result type is void, the C function has no pointer
argument for the result.  If the $SOLLYA result type is $CONSTANT, the
first argument of the C function is of C type §§mpfr_t *§\texttt{mpfr\_t *}§§, the result is
returned by affecting the MPFR variable.  If the $SOLLYA result type
is $FUNCTION, the first argument of the C function is of C type §§node**§\texttt{node **}§§,
the result is returned by the §§node *§\texttt{node *}§§ pointed with a new §§node *§\texttt{node *}§§.
If the $SOLLYA result type is $RANGE, the first argument of the C
function is of C type §§mpfi_t *§\texttt{mpfi\_t *}§§, the result is returned by affecting
the MPFI variable.  If the $SOLLYA result type is $INTEGER, the first
argument of the C function is of C type §§int *§\texttt{int *}§§, the result is returned
by affecting the int variable.  If the $SOLLYA result type is $STRING,
the first argument of the C function is of C type §§char **§\texttt{char **}§§, the result
is returned by the §§char *§\texttt{char *}§§ pointed with a new §§char *§\texttt{char *}§§.  If the $SOLLYA
result type is $BOOLEAN, the first argument of the C function is of C
type §§int *§\texttt{int *}§§, the result is returned by affecting the int variable with
a boolean value.  If the $SOLLYA result type is $LISTOF type, the
first argument of the C function is of C type §§chain **§\texttt{chain **}§§, the result is
returned by the §§chain *§\texttt{chain *}§§ pointed with a new §§chain *§\texttt{chain *}§§.  This chain
contains for $SOLLYA type $CONSTANT pointers §§mpfr_t *§\texttt{mpfr\_t *}§§ to new MPFR
variables, for $SOLLYA type $FUNCTION pointers §§node *§\texttt{node *}§§ to new nodes, for
$SOLLYA type $RANGE pointers §§mpfi_t *§\texttt{mpfi\_t *}§§  to new MPFI variables, for
$SOLLYA type $INTEGER pointers §§int *§\texttt{int *}§§ to new int variables for $SOLLYA
type $STRING pointers §§char *§\texttt{char *}§§ to new §§char *§\texttt{char *}§§ variables and for $SOLLYA
type $BOOLEAN pointers §§int *§\texttt{int *}§§ to new int variables representing boolean
values.
§§ § §§	       
The external procedure affects its possible pointer argument if and
only if it succeeds.  This means, if the function returns an integer
indicating failure, it does not leak any memory to the encompassing
environment.
§§ § §§
The external procedure receives its arguments as follows: If the
$SOLLYA argument type is $VOID, no argument array is given.  Otherwise
the C function receives a C §§void **§\texttt{void **}§§ argument representing an array of
size equal to the arity of the function where each entry (of C type
§§void *§\texttt{void *}§§) represents a value with a C type depending on the
corresponding $SOLLYA type. If the $SOLLYA type is $CONSTANT, the C
type the §§void *§\texttt{void *}§§ is to be casted to is §§mpfr_t *§\texttt{mpfr\_t *}§§.  If the $SOLLYA type
is $FUNCTION, the C type the §§void *§\texttt{void *}§§ is to be casted to is §§node *§\texttt{node *}§§.  If
the $SOLLYA type is $RANGE, the C type the §§void *§\texttt{void *}§§ is to be casted to is
§§mpfi_t *§\texttt{mpfi\_t *}§§.  If the $SOLLYA type is $INTEGER, the C type the §§void *§\texttt{void *}§§ is to
be casted to is §§int *§\texttt{int *}§§.  If the $SOLLYA type is $STRING, the C type the
§§void *§\texttt{void *}§§ is to be casted to is §§char *§\texttt{char *}§§.  If the $SOLLYA type is $BOOLEAN,
the C type the §§void *§\texttt{void *}§§ is to be casted to is §§int *§\texttt{int *}§§.  If the $SOLLYA
type is $LISTOF type, the C type the §§void *§\texttt{void *}§§ is to be casted to is
§§chain *§\texttt{chain *}§§.  Here depending on type, the values in the chain are to be
casted to §§mpfr_t *§\texttt{mpfr\_t *}§§  for $SOLLYA type $CONSTANT, §§node *§\texttt{node *}§§ for $SOLLYA type
$FUNCTION, §§mpfi_t *§\texttt{mpfi\_t *}§§ for $SOLLYA type $RANGE, §§int *§\texttt{int *}§§ for $SOLLYA type
$INTEGER, §§char *§\texttt{char *}§§ for $SOLLYA type $STRING and §§int *§\texttt{int *}§§ for $SOLLYA type
$BOOLEAN.
§§ § §§
The external procedure is not supposed to alter the memory pointed by
its array argument §§void **§\texttt{void **}§§.
§§ § §§
In both directions (argument and result values), empty lists are
represented by §§chain * NULL§\texttt{chain * NULL}§§ pointers.
§§ § §§
In contrast to internal procedures, externally bounded procedures can
be considered to be objects inside $SOLLYA that can be assigned to other
variables, stored in list etc.

#EXAMPLE
bashexecute("gcc -fPIC -Wall -c externalprocexample.c");
bashexecute("gcc -fPIC -shared -o externalprocexample externalprocexample.o");
externalproc(foo, "./externalprocexample", (integer, integer) -> integer);
foo;
foo(5, 6);
verbosity = 1!;
foo();
a = foo;
a(5,6);

#SEEALSO $LIBRARY
#SEEALSO $EXTERNALPLOT
#SEEALSO $BASHEXECUTE
#SEEALSO $VOID
#SEEALSO $CONSTANT
#SEEALSO $FUNCTION
#SEEALSO $RANGE
#SEEALSO $INTEGER
#SEEALSO $STRING
#SEEALSO $BOOLEAN
#SEEALSO $LISTOF

