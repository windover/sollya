\subsection{implementpoly}
\label{labimplementpoly}
\noindent Name: \textbf{implementpoly}\\
implements a polynomial using double, double-double and triple-double arithmetic and generates a Gappa proof\\
\noindent Usage: 
\begin{center}
\textbf{implementpoly}(\emph{polynomial}, \emph{range}, \emph{error bound}, \emph{format}, \emph{functionname}, \emph{filename}) : (\textsf{function}, \textsf{range}, \textsf{constant}, \textsf{D$|$double$|$DD$|$doubledouble$|$TD$|$tripledouble}, \textsf{string}, \textsf{string}) $\rightarrow$ \textsf{function}\\
\textbf{implementpoly}(\emph{polynomial}, \emph{range}, \emph{error bound}, \emph{format}, \emph{functionname}, \emph{filename}, \emph{honor coefficient precisions}) : (\textsf{function}, \textsf{range}, \textsf{constant}, \textsf{D$|$double$|$DD$|$doubledouble$|$TD$|$tripledouble}, \textsf{string}, \textsf{string}, \textsf{honorcoeffprec}) $\rightarrow$ \textsf{function}\\
\textbf{implementpoly}(\emph{polynomial}, \emph{range}, \emph{error bound}, \emph{format}, \emph{functionname}, \emph{filename}, \emph{proof filename}) : (\textsf{function}, \textsf{range}, \textsf{constant}, \textsf{D$|$double$|$DD$|$doubledouble$|$TD$|$tripledouble}, \textsf{string}, \textsf{string}, \textsf{string}) $\rightarrow$ \textsf{function}\\
\textbf{implementpoly}(\emph{polynomial}, \emph{range}, \emph{error bound}, \emph{format}, \emph{functionname}, \emph{filename}, \emph{honor coefficient precisions}, \emph{proof filename}) : (\textsf{function}, \textsf{range}, \textsf{constant}, \textsf{D$|$double$|$DD$|$doubledouble$|$TD$|$tripledouble}, \textsf{string}, \textsf{string}, \textsf{honorcoeffprec}, \textsf{string}) $\rightarrow$ \textsf{function}\\
\end{center}
\noindent Description: \begin{itemize}

\item The command \\textbf{implementpoly} implements the polynomial \\emph{polynomial} in range\n   \\emph{range} as a function called \\emph{functionname} in \\texttt{C} code\n   using double, double-double and triple-double arithmetic in a way that\n   the rounding error (estimated at its first order) is bounded by \\emph{error bound}. \n   The produced code is output in a file named \\emph{filename}. The\n   argument \\emph{format} indicates the double, double-double or triple-double\n   format of the variable in which the polynomial varies, influencing\n   also in the signature of the \\texttt{C} function.\n    \n   If a seventh or eighth argument \\emph{proof filename} is given and if this\n   argument evaluates to a variable of type \\textsf{string}, the command\n   \\textbf{implementpoly} will produce a \\texttt{Gappa} proof that the\n   rounding error is less than the given bound. This proof will be output\n   in \\texttt{Gappa} syntax in a file name \\emph{proof filename}.\n    \n   The command \\textbf{implementpoly} returns the polynomial that has been\n   implemented. As the command \\textbf{implementpoly} tries to adapt the precision\n   needed in each evaluation step to its strict minimum and as it applies\n   renormalization to double-double and triple-double precision\n   coefficients to bring them to a round-to-nearest expansion form, the\n   returned polynomial may differ from the polynomial\n   \\emph{polynomial}. Nevertheless the difference will be small enough that\n   the rounding error bound with regard to the polynomial \\emph{polynomial}\n   (estimated at its first order) will be less than the given error\n   bound.\n    \n   If a seventh argument \\emph{honor coefficient precisions} is given and\n   evaluates to a variable \\textbf{honorcoeffprec} of type \\textsf{honorcoeffprec},\n   \\textbf{implementpoly} will honor the precision of the given polynomial\n   \\emph{polynomials}. This means if a coefficient needs a double-double or a\n   triple-double to be exactly stored, \\textbf{implementpoly} will allocate appropriate\n   space and use a double-double or triple-double operation even if the\n   automatic (heuristic) determination implemented in command \\textbf{implementpoly}\n   indicates that the coefficient could be stored on less precision or,\n   respectively, the operation could be performed with less\n   precision. The use of \\textbf{honorcoeffprec} has advantages and\n   disadvantages. If the polynomial \\emph{polynomial} given has not been\n   determined by a process considering directly polynomials with\n   floating-point coefficients, \\textbf{honorcoeffprec} should not be\n   indicated. The \\textbf{implementpoly} command can then determine the needed\n   precision using the same error estimation as used for the\n   determination of the precisions of the operations. Generally, the\n   coefficients will get rounded to double, double-double and\n   triple-double precision in a way that minimizes their number and\n   respects the rounding error bound \\emph{error bound}.  Indicating\n   \\textbf{honorcoeffprec} may in this case short-circuit most precision\n   estimations leading to sub-optimal code. On the other hand, if the\n   polynomial \\emph{polynomial} has been determined with floating-point\n   precisions in mind, \\textbf{honorcoeffprec} should be indicated because such\n   polynomials often are very sensitive in terms of error propagation with\n   regard to their coefficients' values. Indicating \\textbf{honorcoeffprec}\n   prevents the \\textbf{implementpoly} command from rounding the coefficients and\n   altering by many orders of magnitude the approximation error of the\n   polynomial with regard to the function it approximates.\n    \n   The implementer behind the \\textbf{implementpoly} command makes some assumptions on\n   its input and verifies them. If some assumption cannot be verified,\n   the implementation will not succeed and \\textbf{implementpoly} will evaluate to a\n   variable \\textbf{error} of type \\textsf{error}. The same behaviour is observed if\n   some file is not writable or some other side-effect fails, e.g. if\n   the implementer runs out of memory.\n    \n   As error estimation is performed only on the first order, the code\n   produced by the \\textbf{implementpoly} command should be considered valid iff a\n   \\texttt{Gappa} proof has been produced and successfully run\n   in \\texttt{Gappa}.\n\end{itemize}
\noindent Example 1: 
\begin{center}\begin{minipage}{15cm}\begin{Verbatim}[frame=single]
\end{Verbatim}
\end{minipage}\end{center}
\noindent Example 2: 
\begin{center}\begin{minipage}{15cm}\begin{Verbatim}[frame=single]
\end{Verbatim}
\end{minipage}\end{center}
\noindent Example 3: 
\begin{center}\begin{minipage}{15cm}\begin{Verbatim}[frame=single]
\end{Verbatim}
\end{minipage}\end{center}
\noindent Example 4: 
\begin{center}\begin{minipage}{15cm}\begin{Verbatim}[frame=single]
\end{Verbatim}
\end{minipage}\end{center}
See also: \textbf{honorcoeffprec} (\ref{labhonorcoeffprec}), \textbf{roundcoefficients} (\ref{labroundcoefficients}), \textbf{double} (\ref{labdouble}), \textbf{doubledouble} (\ref{labdoubledouble}), \textbf{tripledouble} (\ref{labtripledouble}), \textbf{readfile} (\ref{labreadfile}), \textbf{printexpansion} (\ref{labprintexpansion}), \textbf{error} (\ref{laberror})
