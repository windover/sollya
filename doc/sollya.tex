\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[naturalnames]{hyperref}
\usepackage{fullpage}
\usepackage{xspace}
\usepackage{amssymb}
\usepackage{fancyvrb}

\newcommand{\com}[1]{\texttt{#1}}
\newcommand{\key}[1]{\texttt{#1}}
\newcommand{\sollya}{\texttt{Sollya}\xspace}
\newcommand{\rlwrap}{\texttt{rlwrap}\xspace}

\newcommand{\code}[1]{
\begin{center}
\begin{tabular}{|p{14.8cm}|}
\hline
#1
\hline
\end{tabular}
\end{center}
}

\newcommand{\ligne}[1]{\texttt{#1}\\}

\begin{document}

\section{Introduction}
\sollya is an interactive tool to handle numerical functions and working with arbitrary precision. It can evaluate functions accurately, compute polynomial approximations of functions, plot functions, compute infinite norms, etc. Let us begin this manual with an example. \sollya does not allow command line edition; since it may quickly become uncomfortable, we highly suggest to use the software \rlwrap with \sollya:

\code{
\ligne{~/\%rlwrap ./tools}
\ligne{>}
}

\sollya manipulates only with univariate functions. The first time that an unbound variable is used, it fixes the name that will be used to refer to the free variable. For instance, try

\code{
\ligne{~/\% rlwrap ./tools}
\ligne{> f = sin(x)/x;}
\ligne{> g = cos(y)-1;}
\ligne{Warning: the identifier "y" is neither assigned to, nor bound to a library }
\ligne{function nor equal to the current free variable.}
\ligne{Will interpret "y" as "x".}
\ligne{> g;}
\ligne{cos(x) - 1}
\ligne{>} 
}

Now, the name $x$ cannot be used to refer to anything but the free variable:

\code{
\ligne{> x=3;}
\ligne{Warning: the identifier "x" is already bound to the free variable or to a }
\ligne{library function}
\ligne{The command will have no effect.}
\ligne{Warning: the last assignment will have no effect.}
\ligne{>}
}

If you really want to unbound $x$, you can use the \com{rename} command and change the name of the free variable:

\code{
\ligne{> rename(x,y);}
\ligne{Information: the free variable has been renamed from "x" to "y".}
\ligne{> g;}
\ligne{cos(y) - 1}
\ligne{> x=3;}
\ligne{> x;}
\ligne{3}
\ligne{> }
}

As you have seen, you can name functions and easily work with. The basic thing to do with a function is to evaluate it at some point:

\code{
\ligne{> evaluatef(-2);}
\ligne{Warning: rounding has happened. The value displayed is a faithful rounding of }
\ligne{the true result.}
\ligne{0.454648713412840847698009932955872421351127485723941}
}

The printed value is generally a faithful rounding of the exact value at the working precision. The working precision is controlled by the global variable \com{prec}:

\code{
\ligne{> prec=?;}
\ligne{165}
\ligne{> prec=200;}
\ligne{The precision has been set to 200 bits.}
\ligne{> prec=?;}
\ligne{200}
\ligne{> f(-2);}
\ligne{Warning: rounding has happened. The value displayed is a faithful rounding of}
\ligne{the true result.}
\ligne{0.45464871341284084769800993295587242135112748572394513418948652}
}

Sometimes, a faithful rounding cannot be easily computed. In such a case, an approximated value is printed:

\code{
\ligne{> sin(pi);}
\ligne{Warning: rounding has happened. The value displayed is not a faithful rounding}
\ligne{of the true result.}
\ligne{0.23702821088022102782921822379162058842068273168003320319597978e-15412}
}

The philosophy of \sollya is: whenever something is not exact, print a warning. This explains the warnings in the previous examples. If the result can be shown to be exact, there is no warning:

\code{
\ligne{> sin(0);}
\ligne{0}
}

Let us finish this Section with a small complete example that shows a bit of what can be done with \sollya:

\code{
\ligne{>  restart;}
\ligne{The tool has been restarted.}
\ligne{> prec=50;}
\ligne{The precision has been set to 50 bits.}
\ligne{> f=cos(2*exp(x));}
\ligne{> d=[-1/8;1/8];}
\ligne{> p=remez(f,2,d);}
\ligne{> derivativeZeros = dirtyfindzeros(diff(p-f),d);}
\ligne{> derivativeZeros = inf(d)::derivativeZeros::sup(d);}
\ligne{> max=0; for t in derivativeZeros do}
\ligne{\{}
\ligne{  r = evaluate(abs(p-f), t);}
\ligne{  if r > max then {max=r; argmax=t;};}
\ligne{\};}
\ligne{> print("The infinite norm of", p-f, "is", max, "and is reached at", argmax);}
\ligne{The infinite norm of (-0.41626557294429078481812212) + x * ((-0.1798067204872539}
\ligne{9037039096583612263e1) + x * (-0.38971068364047456444865247249254026e-1)) - cos(}
\ligne{2 * exp(x)) is 0.86306625059183635084725239e-3 and is reached at -0.580167296300}
\ligne{62879863317e-1}
\ligne{>}
}

In this example, we define a function $f$, an interval $d$ and we compute the best degree-4 polynomial approximation of $f$ on $d$ with respect to the infinite norm. In other words, $\max_{x \in d} \{|p(x)-f(x)|\}$ is minimal amongst polynomials with degree not greater than $4$. Then, we compute the list of the zeros of the derivative of $p-f$ and add the bounds of $d$ to this list. Finally, we evaluate $|p-f|$ for each point in the list and store the maximum and the point where it is reached. We conclude by printing the result in a formatted way (the output was too long to fit in this document. That is why we used \texttt{[...]} to shortcut the actual output).

Note that you do not really need to use such a script for computing infinite norm; as we will see, the command \com{dirtyinfnorm} does this for you.

\section{General principles}
The first goal of \sollya is to help people using numerical functions and numerical algorithm in a safe way. It is first designed to be used interactively but it can also be used in script files.

One of the originalities of \sollya is to work with a multiprecision arithmetic (it uses the library \texttt{MPFR}). For safety purpose \sollya knows how to use interval arithmetic. It uses the interval arithmetic to produce tight and safe results with the precision required by the user.

The general philosophy of \sollya is: \emph{When you can make a computation exactly, do it; when you cannot, do not, unless you have been explicitely asked for.}

The precision of the tools is set by the global variable \key{prec}. It indicates the number of bits used to represent the constants in \sollya. In general, the variable \key{prec} determines the precision of the outputs of commands: more precisely, the command will internally determine what precision should be used during the computations in order to ensure that the output is a faithful result with \key{prec} bits.

For decidability and efficiency reasons, this general principle cannot be applied everytime, so be careful. Moreover certain commands are known to be unsafe: they give in general excellent results and gives almost \key{prec} correct bits in output for everyday examples. However they are just heuristic and should not be used when the result must be safe. See the documentation of each command to know precisely how confident you can be with its result.

A second principle (that comes together with the first one) is: \emph{When a computation leads to inexact results, inform the user with a warning}. This can be quite irritating in some circumstances: in particular if you are using \sollya within other scripts. The global variable \key{verbosity} lets you change the level of verbosity of \sollya. When set to $0$, \sollya becomes completely silent on stdout and prints only very important messages on stderr. Increase \key{verbosity} if you want more informations about what \sollya is doing. Note that when you affect a value to a global variable, a message is always printed even if \com{verbosity} is set to $0$. To affect silently a global variable, use \texttt{!}:

\code{
\ligne{> prec=30;}
\ligne{The precision has been set to 30 bits.}
\ligne{> prec=30!;}
\ligne{>}
}

For conviviality reasons, values are displayed in decimal by default. This lets a normal human being understand the numbers he manipulates. But since constant are internally represented in binary, this causes permanent conversions that are sources of roundings. Thus you are loosing in accuracy and \sollya is always complaining about inexact results. If you just want to store or communicate your results (to another tools for instance) you can use bit-exact representations avaliable in \sollya. The global variable \key{display} defines the way constants are displayed. Here is an example of the four avalaible modes:


\code{
\ligne{> prec=30!;}
\ligne{> a = 17.25;}
\ligne{> display=decimal;}
\ligne{Display mode is decimal numbers.}
\ligne{> a;}
\ligne{0.1725e2}
\ligne{> display=binary;}
\ligne{Display mode is binary numbers.}
\ligne{> a;}
\ligne{1.000101\_2 * 2\^{}(4)}
\ligne{> display=powers;}
\ligne{Display mode is dyadic numbers in integer-power-of-2 notation.}
\ligne{> a;}
\ligne{69 * 2\^{}(-2)}
\ligne{> display=dyadic;}
\ligne{Display mode is dyadic numbers.}
\ligne{> a;}
\ligne{69b-2}
}

The symbol \texttt{e} means $\times 10^\square $ as always. In the same spirit, the symbol \texttt{b} means  $\times 2^\square $. The suffix \texttt{\_2} indicates to \sollya that the previous number has been written in binary. \sollya understands these notations even if you are not in the corresponding \key{display} mode, so you can always use them.

You can also use the standard hexadecimal notation frequently used to represent \texttt{double} numbers. Since this notation cannot represent exactly numbers with arbitrary precision, there is no corresponding \key{display} mode. However, the command \com{printhexa} rounds the value to the nearest \texttt{double} and displays it in hexadecimal:

\code{
\ligne{> printhexa(a);}
\ligne{0x4031400000000000}
}

\section{Data types}
\sollya has a (very) basic system of types. If you try to perform an illicit operation (such as adding a number and a string, for instance), you will get a type error. Let us see the available data types.

\subsection{Booleans}
There are two special values \key{true} and \key{false}. Boolean expressions can be constructed using the boolean connectors \key{\&\&} (and), \key{||} (or), \key{!} (not), and comparisons.

The comparison operators \key{<}, \key{<=}, \key{>} and \key{>=} can be used only between two numbers.

The comparison operators \key{==} and \key{!=} are polymorphic. You can use it to compare two strings, two intervals, etc. Note that testing the equality between two functions will return \key{true} if and only if the expression trees representing the two functions are exactly the same. Example:

\code{
\ligne{> 1+x==1+x;}
\ligne{true}
\ligne{> 1+x==x+1;}
\ligne{false}
}

\subsection{Numbers}
As seen above, \sollya represents numbers as floating-point values with the current precision \com{prec}. A number in an expression is immediately rounded to the precision \com{prec} and the expression is then evaluated:

\code{
\ligne{> prec=12!;}
\ligne{> 4097;}
\ligne{Warning: Rounding occured when converting the constant "4097" to floating-point}
\ligne{with 12 bits.}
\ligne{If safe computation is needed, try to increase the precision.}
\ligne{4096}
\ligne{> 4098;}
\ligne{4098}
\ligne{> 4097+1;}
\ligne{Warning: Rounding occured when converting the constant "4097" to floating-point}
\ligne{with 12 bits.}
\ligne{If safe computation is needed, try to increase the precision.}
\ligne{Warning: rounding has happened. The value displayed is a faithful rounding of}
\ligne{the true result.}
\ligne{4096}
}

Note that each variable has its own precision that corresponds to the value of \com{prec} when the variable was set. Thus you can work with variables having a precision bigger thant the current precision.

In the same spirit, if you define a function that refers to some constant, this constant is stored in the function with the current precision and will keep this value in the future, even if \com{prec} becomes smaller.

If you define a function that refer to some variable, the precision of the variable is kept, independently of the current precision:

\code{
\ligne{> prec=50!;}
\ligne{> a = 4097;}
\ligne{> prec=12!;}
\ligne{> f = x+a;}
\ligne{> g = x+4097;}
\ligne{Warning: Rounding occured when converting the constant "4097" to floating-point}
\ligne{with 12 bits.}
\ligne{If safe computation is needed, try to increase the precision.}
\ligne{> prec=50!;}
\ligne{> f;}
\ligne{4097 + x}
\ligne{> g;}
\ligne{4096 + x}
}

\subsection{Intervals}
Intervals are composed of two numbers representing the lower and the upper bound. These values are separated either by commas or semi-colons:

\code{
\ligne{> d=[1;2];}
\ligne{> d2=[1,2];}
\ligne{> d==d2;}
\ligne{true}
}

The constant are stored with the precision used during the affectation. If you refer to a variable when defining an interval, the precision of the variable is used:

\code{
\ligne{> prec=30!;}
\ligne{> a=4097;}
\ligne{> prec=12!;}
\ligne{> d=[4096; a];}
\ligne{> prec=30!;}
\ligne{> d;}
\ligne{[4096;4097]}
}

You can get the upper-bound (respectively the lower-bound)) of an interval with the function \com{sup} (respectively \com{inf}). The middle of the interval is get with the function \com{mid}. Note that these functions can also be used on numbers (in that case, the number is interpreted as an interval containing only one single point. Thus the functions \com{inf}, \com{mid} and \com{sup} are just the identity):

\code{
\ligne{> d=[1;3];}
\ligne{> inf(d);}
\ligne{1}
\ligne{> mid(d);}
\ligne{2}
\ligne{> sup(4);}
\ligne{4}
}

\subsection{Functions}
\sollya knows only functions with one single variable. The first time in a session that an unbound name is used (without being assigned) it determines the name used to refer to the free variable.

The basic functions available in \sollya are the following:
\begin{itemize}
\item \com{+}, \com{-}, \com{*}, \com{/}, \com{\^{}}
\item \com{sqrt}
\item \com{abs}
\item \com{sin}, \com{cos}, \com{tan}, \com{sinh}, \com{cosh}, \com{tanh}
\item \com{asin}, \com{acos}, \com{atan}, \com{asinh}, \com{atanh}
\item \com{exp}, \com{expm1} (defined as $\mathrm{expm1}(x) = \exp(x)-1$)
\item \com{log} (neperian logarithm), \com{log2} (binary logarithm), \com{log10} (decimal logarithm), \com{log1p} (defined as $\mathrm{log1p}(x) = \log(1+x)$)
\item \com{erf}, \com{erfc}
\end{itemize}

The constant $\pi$ is available as a $0$-ary function: its behavior is exactly the same as if it were a constant with an infinite precision:

\code{
\ligne{> display=binary!;}
\ligne{> prec=12!;}
\ligne{> a=pi;}
\ligne{> a;}
\ligne{Warning: rounding has happened. The value displayed is a faithful rounding of}
\ligne{the true result.}
\ligne{1.10010010001\_2 * 2\^{}(1)}
\ligne{> prec=30!;}
\ligne{> a;}
\ligne{Warning: rounding has happened. The value displayed is a faithful rounding of}
\ligne{the true result.}
\ligne{1.10010010000111111011010101001\_2 * 2\^{}(1)}
}


\subsection{Strings}
Anything written between quotes is interpreted as a string. The infix operator \com{@} concatenates two strings. To get the length of a string, use the \com{length} function. You can access the $i$-th character of a string using brackets (see the example above). There is no char type in \sollya: the $i$-th character of a string is returned as a string itself.

\code{
\ligne{> s1 = "Hello "; s2 = "World!";}
\ligne{> s = s1@s2;}
\ligne{> length(s);}
\ligne{12}
\ligne{> s[0];}
\ligne{H}
\ligne{> s[11];}
\ligne{!}
}

\subsection{Particular values}
\sollya knows some particular values. These values do not really have a type but they can be stored in variables and in lists. A (possibly not exhaustive) list of such values is the following:

\begin{itemize}
\item \com{on}, \com{off}
\item \com{dyadic}, \com{powers}, \com{binary}, \com{decimal}
\item \com{file}, \com{postscript}, \com{postscriptfile}
\item \com{RU}, \com{RD}, \com{RN}, \com{RZ}
\item \com{absolute}, \com{relative}
\item \com{double}, \com{doubleextended}, \com{doubledouble}, \com{tripledouble}
\item \com{D}, \com{DE}, \com{DD}, \com{TD}
\item \com{perturb}
\item \com{honorcoeffprec}
\item \com{default}
\item \com{error}
\end{itemize}

\subsection{Lists}
Objects can be grouped into lists. A list can contain elements with different types. As for strings, you can concatenate two lists with \com{@} and access to an element with brackets. The function \com{length} gives also the length of a list.

You can add an element to the left or the right of a list using \com{::}. The following example illustrates some features:

\code{
\ligne{> list = [| "foo" |];}
\ligne{> list = list::1;}
\ligne{> list = "bar"::list;}
\ligne{> list;}
\ligne{[|bar, foo, 1|]}
\ligne{> list[1];}
\ligne{foo}
\ligne{> list@list;}
\ligne{[|bar, foo, 1, bar, foo, 1|]}
}

\section{Tests and loops}

\section{Commands and functions}

\input{CommandsAndFunctions}

\end{document}