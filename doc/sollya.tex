\documentclass[a4paper]{article}
 
\usepackage[english]{babel}
\usepackage[naturalnames]{hyperref}
\usepackage{fullpage}
\usepackage{xspace}
\usepackage{amssymb}
\usepackage{fancyvrb}

\newcommand{\com}[1]{\texttt{#1}}
\newcommand{\key}[1]{\texttt{#1}}
\newcommand{\sollya}{\texttt{Sollya}\xspace}
\newcommand{\rlwrap}{\texttt{rlwrap}\xspace}

\newcommand{\code}[1]{
\begin{center}
\begin{tabular}{|p{14.8cm}|}
\hline
#1
\hline
\end{tabular}
\end{center}
}

\newcommand{\ligne}[1]{\texttt{#1}\\}

\title{Users' manual for the \sollya tool \\ {\large Release 1.1} \\ ~ \\ {\large Laboratoire de l'Informatique du Parall\'elisme \\ UMR CNRS - ENS Lyon - UCB Lyon 1 - INRIA 5668}}

\author{Sylvain Chevillard \\ \small{\url{sylvain.chevillard@ens-lyon.fr}} \and Christoph Lauter \\ \small{\url{christoph.lauter@ens-lyon.fr}} \and Nicolas Jourdan \\ \small{\url{nicolas.jourdan@ens-lyon.fr}} \and Mioara Joldes \\ \small{\url{mioara.joldes@ens-lyon.fr}} }

\date{\today}


\begin{document}

\maketitle

\section*{License}

The \sollya tool is copyright \copyright~ 2008 Laboratoire de
l'Informatique du Parall\'elisme - UMR CNRS - ENS Lyon - UCB Lyon 1 -
INRIA 5668.  

The \sollya tool is open software. It is distributed and can be used,
modified and redistributed under the terms of the CeCILL-C licence
available at \url{http://www.cecill.info/} and reproduced in the
\texttt{COPYING} file of the distribution. The distribution contains
parts of other libraries as a support for but not integral part of
\sollya. These libraries are reigned by the GNU Lesser General Public
License that is available at \url{http://www.gnu.org/licenses/} and
reproduced in the \texttt{COPYING} file of the distribution.

\tableofcontents

\section{Compilation and installation of the \sollya tool}

\subsection{Compilation dependencies}

The \sollya distribution can be compiled and installed using the usual
\texttt{./configure}, \texttt{make}, \texttt{make install}
procedure. Besides a \texttt{C} compiler, \sollya needs the following
software libraries and tools to be installed. The \texttt{./configure}
script checks for the installation of the libraries. However \sollya
will build without error if some of its external tools is not
installed. In this case an error will be produced at runtime.
\begin{itemize}
\item \texttt{GMP}
\item \texttt{MPFR}
\item \texttt{MPFI}
\item \texttt{fplll}
\item \texttt{libxml2}
\item \texttt{gnuplot}
\end{itemize}
The use of the external tool \texttt{rlwrap} is highly recommended but
not indispensable. Use the \texttt{-A} options of \texttt{rlwrap} for
correctly displayed ANSI X3.64/ ISO/IEC 6429 colored prompts (see
below).

\subsection{\sollya command line options}

In principle \sollya reads all its input on standard input and responds
on standard output. Reading of files is internally supported but no
file names can be given for input when the tool is started. Remark that 
it is nevertheless possible to use Sollya on input contained in a file; 
just redirect standard input to the file, writing on \texttt{bash} for example:
\begin{center}\begin{minipage}{15cm}\begin{Verbatim}[frame=single]
~/% sollya < myfile.sollya 
\end{Verbatim}
\end{minipage}\end{center}

All configurations of the internal state of the tool are done by
commands given on the \sollya prompt. Nevertheless, some command line
options are supported; they work at a very basic I/O-level and can
therefore not be implemented as commands.

The following options are supported when calling \sollya:
\begin{itemize}
\item \texttt{--nocolor}: \sollya supports coloring of the output
  using ANSI X3.64/ ISO/IEC 6429 escape sequences. Coloring is
  deactivated when Sollya is connected on standard input to a file
  that is not a terminal. This option forces the deactivation of ANSI
  coloring. This might be necessary on very old grey-scale terminals or when
  encountering problems with old versions of \texttt{rlwrap}. 
\item \texttt{--noprompt}: \sollya prints a prompt symbol when
  connected on standard input to a pseudo-file that is a terminal. The
  option deactivates the prompt.
\item \texttt{--oldrlwrapcompatible}: This option is deprecated. It
  makes \sollya emit a wrong coloring escape sequence for making it
  compatible with versions of \texttt{rlwrap} that do not support the
  \texttt{-A} option. The option is considered as a hack since it is
  known to garble the output of the tool under some particular
  circumstances.
\item \texttt{--help}: Prints help on the usage of the tool and quits.
\end{itemize}


\section{Introduction}
\sollya is an interactive tool for handling numerical functions and working with arbitrary precision. It can evaluate functions accurately, compute polynomial approximations of functions, automatically implement polynomials for use in math libraries, plot functions, compute infinite norms, etc. The language \sollya comes with is a full-featured script programming language with support for procedures etc. 

Let us begin this manual with an example. \sollya does not allow command line edition; since that may quickly become uncomfortable, we highly suggest to use the software \rlwrap with \sollya:

\begin{center}\begin{minipage}{15cm}\begin{Verbatim}[frame=single]
~/% rlwrap sollya
>
\end{Verbatim}
\end{minipage}\end{center}

\sollya manipulates only functions in one variable. The first time that an unbound variable is used, this name is fixed. It will be used to refer to the free variable. For instance, try

\input{introExample1}

Now, the name $x$ can only be used to refer to the free variable:

\input{introExample2}

If you really want to unbound $x$, you can use the \com{rename} command and change the name of the free variable:

\input{introExample3}

As you have seen, you can name functions and easily work with. The basic thing to do with a function is to evaluate it at some point:

\input{introExample4}

The printed value is generally a faithful rounding of the exact value at the working precision. The working precision is controlled by the global variable \com{prec}:

\input{introExample5}

Sometimes, a faithful rounding cannot easily be computed. In such a case, an approximated value is printed:

\input{introExample6}

The philosophy of \sollya is: whenever something is not exact, print a warning. This explains the warnings in the previous examples. If the result can be shown to be exact, there is no warning:

\input{introExample7}

Let us finish this Section with a small complete example that shows a bit of what can be done with \sollya:

% Warning: this file must be manually corrected: delete the extra ">"
\input{introExample8}

In this example, we define a function $f$, an interval $d$ and we compute the best degree-4 polynomial approximation of $f$ on $d$ with respect to the infinite norm. In other words, $\max_{x \in d} \{|p(x)-f(x)|\}$ is minimal amongst polynomials with degree not greater than $4$. Then, we compute the list of the zeros of the derivative of $p-f$ and add the bounds of $d$ to this list. Finally, we evaluate $|p-f|$ for each point in the list and store the maximum and the point where it is reached. We conclude by printing the result in a formatted way.

Note that you do not really need to use such a script for computing infinite norm; as we will see, the command \com{dirtyinfnorm} does this for you.

\section{General principles}
The first goal of \sollya is to help people to use numerical functions and numerical algorithms in a safe way. It is first designed to be used interactively but it can also be used in scripts\footnote{Remark: some of the behaviors of \sollya slightly change when used in scripts. For example, no prompt is printed.}.

One of the particularities of \sollya is to work with multi-precision arithmetic (it uses the \texttt{MPFR} library). For safety purposes, \sollya knows how to use interval arithmetic. It uses the interval arithmetic to produce tight and safe results with the precision required by the user.

The general philosophy of \sollya is: \emph{When you can make a computation exactly and sufficiently quickly, do it; when you cannot, do not, unless you have been explicitly asked for.}

The precision of the tools is set by the global variable \key{prec}. It indicates the number of bits used to represent the constants in \sollya. In general, the variable \key{prec} determines the precision of the outputs of commands: more precisely, the command will internally determine what precision should be used during the computations in order to ensure that the output is a faithful result with \key{prec} bits.

For decidability and efficiency reasons, this general principle cannot be applied every time, so be careful. Moreover certain commands are known to be unsafe: they give in general excellent results and give almost \key{prec} correct bits in output for everyday examples. However they are just heuristic and should not be used when the result must be safe. See the documentation of each command to know precisely how confident you can be with its result.

A second principle (that comes together with the first one) is: \emph{When a computation leads to inexact results, inform the user with a warning}. This can be quite irritating in some circumstances: in particular if you are using \sollya within other scripts. The global variable \key{verbosity} lets you change the level of verbosity of \sollya. When set to $0$, \sollya becomes completely silent on stdout and prints only very important messages on stderr. Increase \key{verbosity} if you want more information about what \sollya is doing. Note that when you affect a value to a global variable, a message is always printed even if \com{verbosity} is set to $0$. In order to silently affect a global variable, use \texttt{!}:

\input{introExample9}

For conviviality reasons, values are displayed in decimal by default. This lets a normal human being understand the numbers he or she manipulates. But since constants are internally represented in binary, this causes permanent conversions that are sources of roundings. Thus you are loosing in accuracy and \sollya is always complaining about inexact results. If you just want to store or communicate your results (to another tools for instance) you can use bit-exact representations available in \sollya. The global variable \key{display} defines the way constants are displayed. Here is an example of the five available modes:

\input{introExample10}

As always, the symbol \texttt{e} means $\times 10^\square $. The same way the symbol \texttt{b} means  $\times 2^\square $. The symbol \texttt{p} means $\times 16^\square$ and is used only with the \texttt{0x} prefix. The prefix \texttt{0x} indicates that the digits of the following number until 
a symbol \texttt{p} or white-space are hexadecimal. The suffix \texttt{\_2} indicates to \sollya that the previous number has been written in binary. \sollya can parse these notations even if you are not in the corresponding \key{display} mode, so you can always use them.

You can also use memory-dump hexadecimal notation frequently used to represent IEEE 754 \texttt{double} and \texttt{single} precision numbers. Since this notation does not allow for exactly representing numbers with arbitrary precision, there is no corresponding \key{display} mode. However, the commands \com{printhexa} respectively \com{printfloat} round the value to the nearest \texttt{double} respectively \texttt{single}. The number is then printed in hexadecimal as the integer number corresponding to the memory representation of the IEEE 754 \texttt{double} or \texttt{single} number:

\input{introExample11}

\sollya can parse these memory-dump hexadecimal notation back in any \key{display} mode.

\section{Variables}\label{variables}

As already explained, \sollya can manipulate variate functional
expressions in one variable. These expressions contain a unique free variable the name
of which is fixed by its first usage in an expression that is not a
left-hand-side of an assignment. This global and unique free variable is 
a variable in the mathematical sense of the term. 

\sollya also provides variables in the sense programming languages
give to the term.  These variables, that must be different in their
name from the global free variable, may be global or declared and
attached to a block of statements, i.e. a begin-end-block. These
programming language variables may hold any object of the \sollya
language, as for example functional expressions, strings, intervals,
constant values, procedures, external functions and procedures, etc.

Global variables need not to be declared. They start existing,
i.e. can be correctly used in expressions that are not left-hand-sides
of assignments, when they are assigned a value in an assignment. Since
they are global, this kind of variables is recommended only for small
\sollya scripts.  Larger scripts with code reutilisation should use
declared variables in order to avoid name clashes for example in loop
variables.

Declared variables are attached to a begin-end-block. The block
structure builds scopes for declared variables. Declared variables in
inner scopes shadow variables (global and declared) of outer
scopes. The global free variable, i.e. the mathematical variable for
variate functional expressions in one variable, cannot be shadowed. Variables are
declared using \key{var} keyword. See section \ref{labvar} for details
on its usage and semantic.

The following code examples illustrate the usage of variables.


\input{introExample12}

\section{Data types}
\sollya has a (very) basic system of types. If you try to perform an illicit operation (such as adding a number and a string, for instance), you will get a type error. Let us see the available data types.

\subsection{Booleans}
There are two special values \key{true} and \key{false}. Boolean expressions can be constructed using the boolean connectors \key{\&\&} (and), \key{||} (or), \key{!} (not), and comparisons.

The comparison operators \key{<}, \key{<=}, \key{>} and \key{>=} can only be used between two numbers or constant expressions.

The comparison operators \key{==} and \key{!=} are polymorphic. You can use it to compare any two objects, like two strings, two intervals, etc. Note that testing the equality between two functions will return \key{true} if and only if the expression trees representing the two functions are exactly the same. See \ref{laberror} for an exception concerning the special object \key{error}. Example:

\input{introExample13}

\subsection{Numbers}
\sollya represents numbers as floating-point values. For integer values and values in dyadic, binary, hexadecimal or memory dump notation, it 
automatically uses a precision needed for representing the value exactly. Otherwise the values are represented with the current precision \com{prec}. A number in an expression is rounded to the precision \com{prec} when the expression gets evaluated:

\input{introExample14}

Note that each variable has its own precision that corresponds to its intrinsic precision or, if it cannot be represented, to the value of \com{prec} when the variable was set. Thus you can work with variables having a precision bigger than the current precision.

The same way, if you define a function that refers to some constant, this constant is stored in the function with the current precision and will keep this value in the future, even if \com{prec} becomes smaller.

If you define a function that refers to some variable, the precision of the variable is kept, independently of the current precision:

\input{introExample15}

\subsection{Intervals}
Intervals are composed of two numbers or constant expressions representing the lower and the upper bound. These values are separated either by commas or semi-colons:

\input{introExample16}

If bounds are defined by constant expressions, these are evaluated to floating-point numbers using the current precision. Numbers or variables containing numbers keep their precision for the interval bounds. Interval bound evaluation is performed in a way that ensures the inclusion property: all points
in the original, unevaluated interval will be contained in the interval with its bounds evaluated to floating-point numbers. Remark that 
evaluation bounds defined by constant expressions includes $\pi$:

\input{introExample17}

You can get the upper-bound (respectively the lower-bound)) of an interval with the function \com{sup} (respectively \com{inf}). The middle of the interval is got with the function \com{mid}. Note that these functions can also be used on numbers (in that case, the number is interpreted as an interval containing only one single point. Thus the functions \com{inf}, \com{mid} and \com{sup} are just the identity):

\input{introExample18}

\subsection{Functions}
\sollya knows only functions with one single variable. The first time in a session that an unbound name is used (without being assigned) it determines the name used to refer to the free variable.

The basic functions available in \sollya are the following:
\begin{itemize}
\item \com{+}, \com{-}, \com{*}, \com{/}, \com{\^{}}
\item \com{sqrt}
\item \com{abs}
\item \com{sin}, \com{cos}, \com{tan}, \com{sinh}, \com{cosh}, \com{tanh}
\item \com{asin}, \com{acos}, \com{atan}, \com{asinh}, \com{atanh}
\item \com{exp}, \com{expm1} (defined as $\mathrm{expm1}(x) = \exp(x)-1$)
\item \com{log} (natural logarithm), \com{log2} (binary logarithm), \com{log10} (decimal logarithm), \com{log1p} (defined as $\mathrm{log1p}(x) = \log(1+x)$)
\item \com{erf}, \com{erfc}
\end{itemize}

The constant $\pi$ is available through the keyword \key{pi} as a $0$-ary function: its behavior is exactly the same as if it were a constant with an infinite precision:

\input{introExample19}

\subsection{Strings}
Anything written between quotes is interpreted as a string. The infix operator \com{@} concatenates two strings. To get the length of a string, use the \com{length} function. You can access the $i$-th character of a string using brackets (see the example below). There is no character type in \sollya: the $i$-th character of a string is returned as a string itself.

\input{introExample20}

Strings may contain the following escape sequences:
\texttt{$\backslash\backslash$}, \texttt{$\backslash$\"},
\texttt{$\backslash$?}, \texttt{$\backslash$\'},
\texttt{$\backslash$n}, \texttt{$\backslash$t},
\texttt{$\backslash$a}, \texttt{$\backslash$b},
\texttt{$\backslash$f}, \texttt{$\backslash$r},
\texttt{$\backslash$v}, \texttt{$\backslash$x}[hexadecimal number] and
\texttt{$\backslash$}[octal number]. Refer to the C99 standard for their
meaning.

\subsection{Particular values}
\sollya knows some particular values. These values do not really have a type but they can be stored in variables and in lists. A (possibly not exhaustive) list of such values is the following:

\begin{itemize}
\item \com{on}, \com{off} (see sections \ref{labon} and \ref{laboff})
\item \com{dyadic}, \com{powers}, \com{binary}, \com{decimal}, \com{hexadecimal} (see sections \ref{labdyadic}, \ref{labpowers}, \ref{labbinary}, \ref{labdecimal} and \ref{labhexadecimal})
\item \com{file}, \com{postscript}, \com{postscriptfile} (see sections \ref{labfile}, \ref{labpostscript} and \ref{labpostscriptfile})
\item \com{RU}, \com{RD}, \com{RN}, \com{RZ} (see sections \ref{labru}, \ref{labrd}, \ref{labrn} and \ref{labrz})
\item \com{absolute}, \com{relative} (see sections \ref{lababsolute} and \ref{labrelative})
\item \com{floating}, \com{fixed} (see sections \ref{labfloating} and \ref{labfixed})
\item \com{double}, \com{doubleextended}, \com{doubledouble}, \com{tripledouble} (see sections \ref{labdouble}, \ref{labdoubleextended}, \ref{labdoubledouble} and \ref{labtripledouble})
\item \com{D}, \com{DE}, \com{DD}, \com{TD} (see sections \ref{labdouble}, \ref{labdoubleextended}, \ref{labdoubledouble} and \ref{labtripledouble})
\item \com{perturb} (see section \ref{labperturb})
\item \com{honorcoeffprec} (see section \ref{labhonorcoeffprec})
\item \com{default} (see section \ref{labdefault})
\item \com{error} (see section \ref{laberror})
\item \com{void} (see section \ref{labvoid})
\end{itemize}

\subsection{Lists}
Objects can be grouped into lists. A list can contain elements with different types. As for strings, you can concatenate two lists with \com{@}. The function \com{length} gives also the length of a list.

You can prepend an element to a list using \com{.:} (in $\mathcal{O}(1)$) and you can append an element to a list using \com{:.} (in $\mathcal{O}(n)$). The following example illustrates some features:

\input{introExample21}

Lists can be considered as arrays and elements of lists can be
referenced using brackets. Possible indices start at $0$. The
following example illustrates this point:

\input{introExample22}

Remark that the complexity for accessing an element of the list using
indices is $\mathcal{O}(n)$.

Lists may contain ellipses indicated by \texttt{,...,} between
elements that are constant and evaluate to integers that are
incrementally ordered. \sollya translates such ellipses to the full
list upon evaluation. Using ellipses between elements that are not
constants is not allowed. This feature is provided for ease of
programming; remark that the complexity of expanding such lists is
high. For illustration, see the following example:

\input{introExample23}

Lists may be continued to infinity by means of the \texttt{...}
indicator after the last element given. At least one element must
explicitly be given. If the last element given is a constant
expression that evaluates to an integer, the list is considered as
continued to infinity by all integers greater than that last
element. If the last element is another object, the list is considered
as continued to infinity by re-duplicating this last element. Remark
that bracket notation is supported for such end-elliptic lists even
for implicitly given elements. However, evaluation complexity is
high. Combinations of ellipses inside a list and in its end are
possible. The usage of lists described here is best illustrated by the
following examples:

\input{introExample24}

\section{Iterative language elements: assignments, conditional statements and loops}

\subsection{Blocks}

Statements in \sollya can be regrouped in blocks, so-called
begin-end-blocks.  This can be done using the keywords \key{begin} and
\key{end} or their shorter variants \key{$\lbrace$} and
\key{$\rbrace$}. Blocks declared this way are considered as one single
statement. As already explained in section \ref{variables}, using
begin-end-blocks also opens the possibility of declaring variables
through the keyword \key{var}. 

\subsection{Assignments}

\sollya has two different assignment operators, \texttt{=} and
\texttt{:=}. The assignment operator \texttt{=} assigns its
right-hand-object ``as is'', i.e. without evaluating functional
expressions. For instance, \texttt{i = i + 1;} will dereferentiate the
identifier \texttt{i} with some content, notate it $y$, build up the
expression (function) $y + 1$ and assign this expression back to
\texttt{i}. In the example, if \texttt{i} stood for the value $1000$,
the statement \texttt{i = i + 1;} will assign $1000 + 1$ -- and not
$1001$ -- to \texttt{i}. The assignment operator \texttt{:=} evaluates
constant functional expressions before assigning them. On other
expressions it behaves like \texttt{=}. Still in the example, the
statement \texttt{i := i + 1;} really assigns $1001$ to \texttt{i}.

Both \sollya assignment operators support indexing of lists or strings
elements using brackets on the left-hand-side of the assignment
operator. The indexed element of the list or string gets replaced by
the right-hand-side of the assignment operator.  When indexing strings
this way, that right-hand side must evaluate to a string of length
$1$. End-elliptic lists are supported with their usual semantic for
this kind of assignment.  When referencing and assigning a value in
the implicit part of the end-elliptic list, the list gets expanded to
the corresponding length. The indexing of lists on left-hand sides of
assignments is reduced to the first order. Multiple indexing of lists
of lists is not supported for complexity reasons. 

The following examples well illustrate the behavior of assignment
statements:

\input{introExample25}

\subsection{Conditional statements}

\sollya supports conditional statements expressed with the keywords
\key{if}, \key{then} and optionally \key{else}. Remark that only
conditional statements are supported not conditional expressions. 

The following examples illustrate both syntax and semantic of
conditional statements in \sollya. Concerning syntax, consider also
section \ref{grammar} and remark that there must not be any semicolon
before the \key{else} keyword.

\input{introExample26}

\subsection{Loops}

\sollya supports three kinds of loops. General \emph{while-condition}
loops can be expressed using the keywords \key{while} and
\key{do}. Remark that the condition test is executed always before the
loop, there is no \emph{do-until-condition} loop. Consider the following 
examples for both syntax and semantic:

\input{introExample27}

The second kind of loops are loops on a variable ranging from a
numerical start value and a end value. These kind of loops can be
expressed using the keywords \key{for}, \key{from}, \key{to}, \key{do}
and optionally \key{by}. The \key{by} statement indicates the width of
the steps on the variable from the start value to the end value. Once
again, syntax and semantic are best explained with an example:

\input{introExample28}

The third kind of loops are loops on a variables ranging on values
contained in a list. In order to ensure the termination of the loop,
that list must not be end-elliptic. The loop is expressed using the
keywords \key{for}, \key{in} and \key{do} as in the following
examples:

\input{introExample29}

For both types of \key{for} loops, assigning the loop variable is
allowed and possible. If the loop terminates, the loop variable will
contain the value that made the loop condition fail. Consider the
following examples:

\input{introExample30}

\section{Functional language elements: procedures}

\sollya has some elements of functional languages. In order to 
avoid confusion with mathematical functions, the associated 
programming objects are called procedures in \sollya. 

\sollya procedures are common objects that can be, for example,
assigned to variables or stored in lists. Procedures are declared by
the \key{proc} keyword; see section \ref{labproc} for details. The
returned procedure object must then be assigned to a variable and can
hence be applied to arguments with common application syntax. The
\key{procedure} keyword provides an abbreviation for declaring and
assigning a procedure; see section \ref{labprocedure} for details.

\sollya procedures can return objects using the \key{return} keyword
at the end of the begin-end-block of the procedure. Section
\ref{labreturn} gives details on the usage of \key{return}. Procedures
further can take any type of object in argument, in particular also
other procedures that are then applied to arguments. Procedures can
be declared inside other procedures. 

Remark that declaring a procedure does not involve any evaluation or
other interpretation of the procedure body. In particular, this means
that constants are evaluated to floating-point values inside \sollya
when the procedure is applied to actual parameters and the global
precision valid at this moment.

\sollya procedures are well illustrated by the following examples:

\input{introExample31}

\sollya also supports external procedures, i.e. procedures written in
\texttt{C} (or some other language) and dynamically bound to \sollya
identifiers. See \ref{labexternalproc} for details.

\section{Commands and functions}

\input{CommandsAndFunctions}


\end{document}