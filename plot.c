#include <gmp.h>
#include <mpfr.h>
#include <stdio.h> /* fprintf, fopen, fclose, */
#include <sys/types.h> /* pid_t */
#include <sys/wait.h> /* wait */
#include <unistd.h> /* execve, fork, daemon */
#include <stdlib.h> /* exit, free, mktemp */
#include <errno.h>
#include <string.h>
#include "plot.h"
#include "expression.h"
#include "main.h"
#include "infnorm.h"
#include "chain.h"

#define MAX_VALUE_GNUPLOT 0.898846567431157854072637118658521783990352837629224983e308

void checkFileDescriptor(FILE *fd, char *s) {
  if (fd == NULL) {
    fprintf(stderr,"Error: the file %s requested by plot could not be opened for writing: ",s);
    fprintf(stderr,"\"%s\".\n",strerror(errno));
    recoverFromError();

  }
  return;
}

void plotTree(chain *treeList, mpfr_t a, mpfr_t b, unsigned long int points, mp_prec_t prec, char *name, int type) {
  int test, i;
  chain *list;
  node *tree;
  mpfr_t x, y, step;
  double xd, yd, ad, bd;
  FILE *file;
  char *gplotname;
  char *dataname;
  char *outputname;

  mpfr_init2(x, prec);
  mpfr_init2(step, prec);
  mpfr_init2(y, 12);
 
  mpfr_sub(step, b, a, GMP_RNDN);
  mpfr_div_ui(step, step, points, GMP_RNDN);
 
  if (mpfr_sgn(step) == 0) {
    list = treeList;
    mpfr_set_prec(y,prec);
    while(list != NULL) {
      tree = (node *)(list->value);
      evaluateFaithful(y,tree,a,prec);
      if (!mpfr_number_p(y)) {
	printMessage(1,"Warning: this constant function is not evaluable by this tool.\n");
      } 
      printValue(&y,prec);
      printf("\n");
      list = list->next;
    }
    mpfr_clear(x); mpfr_clear(y); mpfr_clear(step);
    return;
  }

  if (mpfr_sgn(step) < 0) {
    printMessage(1,"Warning: the interval is empty\n");
    mpfr_clear(x); mpfr_clear(y); mpfr_clear(step);
    return;
  }

  test=1;
  list = treeList;
  while(list != NULL && (test==1)) {
    tree = (node *)(list->value);
    if(!isConstant(tree)) test=0;
    list = list->next;
  }
 
  if (test) {
    mpfr_set_prec(y,prec);
    mpfr_set_d(x,1.0,GMP_RNDN);
    list = treeList;
    while(list != NULL && (test==1)) {
      tree = (node *)(list->value);
      evaluateFaithful(y,tree,x,prec);
      if (!mpfr_number_p(y)) {
	printMessage(1,"Warning: this constant function is not evaluable by this tool.\n");
      } 
      printValue(&y,prec);
      printf("\n");
      list = list->next;
    }
    mpfr_clear(x); mpfr_clear(y); mpfr_clear(step);
    return;
  }

  if(name==NULL) {
    gplotname = (char *)safeCalloc(26, sizeof(char));
    sprintf(gplotname,"/tmp/arenairetools-0001.p");
    dataname = (char *)safeCalloc(28, sizeof(char));
    sprintf(dataname,"/tmp/arenairetools-0001.dat");
    outputname = (char *)safeCalloc(1, sizeof(char));
  }
  else {
    gplotname = (char *)safeCalloc(strlen(name)+3,sizeof(char));
    sprintf(gplotname,"%s.p",name);
    dataname = (char *)safeCalloc(strlen(name)+5,sizeof(char));
    sprintf(dataname,"%s.dat",name);
    outputname = (char *)safeCalloc(strlen(name)+5,sizeof(char));   
    if ((type==PLOTPOSTSCRIPT) || (type==PLOTPOSTSCRIPTFILE)) sprintf(outputname,"%s.eps",name);
  }

  file = fopen(gplotname, "w");
  checkFileDescriptor(file, gplotname);
  fprintf(file, "# Gnuplot script generated by ArenaireTools\n");
  ad = mpfr_get_d(a, GMP_RNDD);
  bd = mpfr_get_d(b, GMP_RNDU);
  if ((ad-ad != 0) || (bd-bd != 0))
    printMessage(1, "Warning: an overflow occured in a conversion mpfr -> double while plotting.\n");
  if (ad-ad != 0)
    ad = -MAX_VALUE_GNUPLOT;
  if (bd-bd != 0)
    bd = MAX_VALUE_GNUPLOT;
  if ((type==PLOTPOSTSCRIPT) || (type==PLOTPOSTSCRIPTFILE)) fprintf(file,"set terminal postscript eps color\nset out \"%s\"\n",outputname);
  fprintf(file, "set xrange [%1.50e:%1.50e]\n",  ad, bd);

  fprintf(file, "plot ");
  i=2;
  list = treeList;
  while(list != NULL) {
    fprintf(file,"\"%s\" using 1:%d with lines t \"\"",dataname,i);
    if(list->next != NULL) fprintf(file,",");
    i++;
    list = list->next;
  }
  fprintf(file,"\n");
  fclose(file);

  file = fopen(dataname, "w");
  checkFileDescriptor(file, dataname);
 
  for(mpfr_set(x,a,GMP_RNDN); mpfr_lessequal_p(x,b); mpfr_add(x,x,step,GMP_RNDN)) {
    xd =  mpfr_get_d(x, GMP_RNDN);
    if (xd >= MAX_VALUE_GNUPLOT) xd = MAX_VALUE_GNUPLOT;
    if (xd <= -MAX_VALUE_GNUPLOT) xd = -MAX_VALUE_GNUPLOT;
    fprintf(file, "%1.50e",xd);

    list = treeList;
    while(list != NULL) {
      tree = (node *)(list->value);
      evaluateFaithful(y,tree,x,prec);
      if (!mpfr_number_p(y)) {
	printMessage(2,"Information: function undefined or not evaluable in point %s = ",variablename);
	if (verbosity >= 2) printValue(&x,prec);
	printMessage(2,"\nThis point will not be plotted.\n");
      }
      yd = mpfr_get_d(y, GMP_RNDN);
      if (yd >= MAX_VALUE_GNUPLOT) yd = MAX_VALUE_GNUPLOT;
      if (yd <= -MAX_VALUE_GNUPLOT) yd = -MAX_VALUE_GNUPLOT;
      fprintf(file, "\t%1.50e", yd);
      
      list = list->next;
    }
    fprintf(file,"\n");
  }
 
  fclose(file);
  mpfr_clear(x); mpfr_clear(y); mpfr_clear(step);

  if ((name==NULL) || (type==PLOTFILE)) {
    if (fork()==0) {
      daemon(1,1);
      execlp("gnuplot", "gnuplot", "-persist", gplotname, NULL);
      perror("An error occured when calling gnuplot ");
      exit(1);
    }
    else wait(NULL);
  }
  else { /* Case we have an output: no daemon */
    if (fork()==0) {
      execlp("gnuplot", "gnuplot", "-persist", gplotname, NULL);
      perror("An error occured when calling gnuplot ");
      exit(1);
    }
    else {
      wait(NULL);
      if((type==PLOTPOSTSCRIPT)) {
	remove(gplotname);
	remove(dataname);
      }
    }
  }
  
  free(gplotname);
  free(dataname);
  free(outputname);
  return;

}
