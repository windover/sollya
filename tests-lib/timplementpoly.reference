implementpoly(1 - 1b-3 * x^2,[-1b-10;1b-10],1b-60,doubledouble,p,"timplementpoly.implementation.c") returns 1 + x^2 * (-1b-3) and produces the following code:

#define p_coeff_0h 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000e+00
#define p_coeff_2h -1.25000000000000000000000000000000000000000000000000000000000000000000000000000000e-01


void p(double *p_resh, double *p_resm, double xh, double xm) {
double p_x_0_pow2h;


p_x_0_pow2h = xh * xh;


double p_t_1_0h;
double p_t_2_0h;
double p_t_3_0h, p_t_3_0m;
 


p_t_1_0h = p_coeff_2h;
p_t_2_0h = p_t_1_0h * p_x_0_pow2h;
Add12(p_t_3_0h,p_t_3_0m,p_coeff_0h,p_t_2_0h);
*p_resh = p_t_3_0h; *p_resm = p_t_3_0m;


}

Caught the message: the infered precision of a coefficient is higher than what seems to be needed to meet the accuracy target.
implementpoly(1 - 348449143727040986587676189630848059834369b-140 * x^2,[-1b-10;1b-10],1b-60,doubledouble,p,"timplementpoly.implementation.c",honorcoeffprec) returns 1 + x^2 * (-348449143727040986587676189630848059834369b-140) and produces the following code:

#define p_coeff_0h 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000e+00
#define p_coeff_2h -2.50000000000000000000000000000000000000000000000000000000000000000000000000000000e-01
#define p_coeff_2m -8.47032947254300339068322500679641962051391600000000000000000000000000000000000000e-22
#define p_coeff_2l -7.17464813734306340312949546644437059215494100000000000000000000000000000000000000e-43


void p(double *p_resh, double *p_resm, double xh, double xm) {
double p_x_0_pow2h, p_x_0_pow2m, p_x_0_pow2l;


Mul23(&p_x_0_pow2h,&p_x_0_pow2m,&p_x_0_pow2l,xh,xm,xh,xm);


double p_t_1_0h, p_t_1_0m, p_t_1_0l;
double p_x_1_pow2h, p_x_1_pow2m, p_x_1_pow2l;
double p_t_1_1h, p_t_1_1m, p_t_1_1l;
double p_t_2_0h, p_t_2_0m, p_t_2_0l;
double p_t_2_1h, p_t_2_1m, p_t_2_1l;
double p_t_3_0h, p_t_3_0m, p_t_3_0l;
 


p_t_1_0h = p_coeff_2h; p_t_1_0m = p_coeff_2m; p_t_1_0l = p_coeff_2l;
Renormalize3(&p_x_1_pow2h,&p_x_1_pow2m,&p_x_1_pow2l,p_x_0_pow2h,p_x_0_pow2m,p_x_0_pow2l);
Renormalize3(&p_t_1_1h,&p_t_1_1m,&p_t_1_1l,p_t_1_0h,p_t_1_0m,p_t_1_0l);
Mul33(&p_t_2_0h,&p_t_2_0m,&p_t_2_0l,p_x_1_pow2h,p_x_1_pow2m,p_x_1_pow2l,p_t_1_1h,p_t_1_1m,p_t_1_1l);
Renormalize3(&p_t_2_1h,&p_t_2_1m,&p_t_2_1l,p_t_2_0h,p_t_2_0m,p_t_2_0l);
Add133(&p_t_3_0h,&p_t_3_0m,&p_t_3_0l,p_coeff_0h,p_t_2_1h,p_t_2_1m,p_t_2_1l);
Renormalize3(p_resh,p_resm,p_resl,p_t_3_0h,p_t_3_0m,p_t_3_0l);


}

Caught the message: a coefficient in a Horner scheme is not guaranteed to also be twice as large as the subpolynomial.
Caught the message: the infered precision of a coefficient is higher than what seems to be needed to meet the accuracy target.
Caught the message: an error has occured during the determination of the required precisions.
implementpoly(1 + x + 1b-1 * x^2 + 1b-2 * x^3 + 1b-3 * x^4 + 1b-4 * x^5 + 1b-5 * x^6 + 1b-6 * x^7,[-1b-1;1b-1],1b-60,doubledouble,p,"timplementpoly.implementation.c",honorcoeffprec,"timplementpoly.implementation.gappa") returns 1 + x * (1 + x * (1b-1 + x * (1b-2 + x * (1b-3 + x * (1b-4 + x * (1b-5 + x * 1b-6)))))) and produces the following code:

#define p_coeff_0h 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000e+00
#define p_coeff_1h 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000e+00
#define p_coeff_2h 5.00000000000000000000000000000000000000000000000000000000000000000000000000000000e-01
#define p_coeff_3h 2.50000000000000000000000000000000000000000000000000000000000000000000000000000000e-01
#define p_coeff_4h 1.25000000000000000000000000000000000000000000000000000000000000000000000000000000e-01
#define p_coeff_5h 6.25000000000000000000000000000000000000000000000000000000000000000000000000000000e-02
#define p_coeff_6h 3.12500000000000000000000000000000000000000000000000000000000000000000000000000000e-02
#define p_coeff_7h 1.56250000000000000000000000000000000000000000000000000000000000000000000000000000e-02


void p(double *p_resh, double *p_resm, double xh, double xm) {




double p_t_1_0h;
double p_t_2_0h;
double p_t_3_0h;
double p_t_4_0h;
double p_t_5_0h, p_t_5_0m;
double p_t_6_0h, p_t_6_0m;
double p_t_7_0h, p_t_7_0m;
double p_t_8_0h, p_t_8_0m;
double p_t_9_0h, p_t_9_0m;
double p_t_10_0h, p_t_10_0m;
double p_t_11_0h, p_t_11_0m;
double p_t_12_0h, p_t_12_0m;
double p_t_13_0h, p_t_13_0m;
double p_t_14_0h, p_t_14_0m;
double p_t_15_0h, p_t_15_0m;
 


p_t_1_0h = p_coeff_7h;
p_t_2_0h = p_t_1_0h * xh;
p_t_3_0h = p_coeff_6h + p_t_2_0h;
p_t_4_0h = p_t_3_0h * xh;
Add12(p_t_5_0h,p_t_5_0m,p_coeff_5h,p_t_4_0h);
Mul22(&p_t_6_0h,&p_t_6_0m,p_t_5_0h,p_t_5_0m,xh,xm);
Add122(&p_t_7_0h,&p_t_7_0m,p_coeff_4h,p_t_6_0h,p_t_6_0m);
Mul22(&p_t_8_0h,&p_t_8_0m,p_t_7_0h,p_t_7_0m,xh,xm);
Add122(&p_t_9_0h,&p_t_9_0m,p_coeff_3h,p_t_8_0h,p_t_8_0m);
Mul22(&p_t_10_0h,&p_t_10_0m,p_t_9_0h,p_t_9_0m,xh,xm);
Add122(&p_t_11_0h,&p_t_11_0m,p_coeff_2h,p_t_10_0h,p_t_10_0m);
Mul22(&p_t_12_0h,&p_t_12_0m,p_t_11_0h,p_t_11_0m,xh,xm);
Add122(&p_t_13_0h,&p_t_13_0m,p_coeff_1h,p_t_12_0h,p_t_12_0m);
Mul22(&p_t_14_0h,&p_t_14_0m,p_t_13_0h,p_t_13_0m,xh,xm);
Add122(&p_t_15_0h,&p_t_15_0m,p_coeff_0h,p_t_14_0h,p_t_14_0m);
*p_resh = p_t_15_0h; *p_resm = p_t_15_0m;


}

Additionnally, the following Gappa proof is produced:

# The polynomial to implement is: ((((((1b0 + x) + (1b-1 * (x^(1b1)))) + (1b-2 * (x^(3b0)))) + (1b-3 * (x^(1b2)))) + (1b-4 * (x^(5b0)))) + (1b-5 * (x^(3b1)))) + (1b-6 * (x^(7b0)))
# The polynomial implemented is: 1b0 + (x * (1b0 + (x * (1b-1 + (x * (1b-2 + (x * (1b-3 + (x * (1b-4 + (x * (1b-5 + (x * 1b-6)))))))))))))
# The domain is [-1b-1;1b-1]
# The free variable x is a double-double number, the result p_res* is stored on a double-double number.
# The code produces 24 intermediate and final arithmetical approximations.

# Double precision rounding operator:
@double = float<ieee_64,ne>;

# Disable some annoying warnings:
#@-Wno-dichotomy-failure

# Helper definitions for decomposing the free variable
xh = double(xhm);
xm = xhm - xh;

# Transcription of the C code
p_coeff_0h = double(1.00000000000000000000000000000000000000000000000000000000000000000000000000000000e+00);

p_coeff_1h = double(1.00000000000000000000000000000000000000000000000000000000000000000000000000000000e+00);

p_coeff_2h = double(5.00000000000000000000000000000000000000000000000000000000000000000000000000000000e-01);

p_coeff_3h = double(2.50000000000000000000000000000000000000000000000000000000000000000000000000000000e-01);

p_coeff_4h = double(1.25000000000000000000000000000000000000000000000000000000000000000000000000000000e-01);

p_coeff_5h = double(6.25000000000000000000000000000000000000000000000000000000000000000000000000000000e-02);

p_coeff_6h = double(3.12500000000000000000000000000000000000000000000000000000000000000000000000000000e-02);

p_coeff_7h = double(1.56250000000000000000000000000000000000000000000000000000000000000000000000000000e-02);

p_t_1_0h = p_coeff_7h;

p_t_2_0h = double(p_t_1_0h * xh);
p_t_3_0h = double(p_coeff_6h + p_t_2_0h);
p_t_4_0h = double(p_t_3_0h * xh);
p_t_5_0hm = p_coeff_5h + p_t_4_0h;
p_t_5_0h = double(p_t_5_0hm);
p_t_5_0m = p_t_5_0hm - p_t_5_0h;

p_t_6_0hm = mul_rel<102>(p_t_5_0hm,xhm);
p_t_6_0h = double(p_t_6_0hm);
p_t_6_0m = p_t_6_0hm - p_t_6_0h;

p_t_7_0hm = add_rel<102>(p_coeff_4h,p_t_6_0hm);
p_t_7_0h = double(p_t_7_0hm);
p_t_7_0m = p_t_7_0hm - p_t_7_0h;

p_t_8_0hm = mul_rel<102>(p_t_7_0hm,xhm);
p_t_8_0h = double(p_t_8_0hm);
p_t_8_0m = p_t_8_0hm - p_t_8_0h;

p_t_9_0hm = add_rel<102>(p_coeff_3h,p_t_8_0hm);
p_t_9_0h = double(p_t_9_0hm);
p_t_9_0m = p_t_9_0hm - p_t_9_0h;

p_t_10_0hm = mul_rel<102>(p_t_9_0hm,xhm);
p_t_10_0h = double(p_t_10_0hm);
p_t_10_0m = p_t_10_0hm - p_t_10_0h;

p_t_11_0hm = add_rel<102>(p_coeff_2h,p_t_10_0hm);
p_t_11_0h = double(p_t_11_0hm);
p_t_11_0m = p_t_11_0hm - p_t_11_0h;

p_t_12_0hm = mul_rel<102>(p_t_11_0hm,xhm);
p_t_12_0h = double(p_t_12_0hm);
p_t_12_0m = p_t_12_0hm - p_t_12_0h;

p_t_13_0hm = add_rel<102>(p_coeff_1h,p_t_12_0hm);
p_t_13_0h = double(p_t_13_0hm);
p_t_13_0m = p_t_13_0hm - p_t_13_0h;

p_t_14_0hm = mul_rel<102>(p_t_13_0hm,xhm);
p_t_14_0h = double(p_t_14_0hm);
p_t_14_0m = p_t_14_0hm - p_t_14_0h;

p_t_15_0hm = add_rel<102>(p_coeff_0h,p_t_14_0hm);
p_t_15_0h = double(p_t_15_0hm);
p_t_15_0m = p_t_15_0hm - p_t_15_0h;

p_reshm = p_t_15_0hm;
p_resh = p_t_15_0h;
p_resm = p_t_15_0m;


# Mathematical equivalents
Mx = xhm;
Mp_coeff_0 = p_coeff_0h;
Mp_coeff_1 = p_coeff_1h;
Mp_coeff_2 = p_coeff_2h;
Mp_coeff_3 = p_coeff_3h;
Mp_coeff_4 = p_coeff_4h;
Mp_coeff_5 = p_coeff_5h;
Mp_coeff_6 = p_coeff_6h;
Mp_coeff_7 = p_coeff_7h;
Mp_t_1_0 = Mp_coeff_7;
Mp_t_2_0 = Mp_t_1_0 * Mx;
Mp_t_3_0 = Mp_coeff_6 + Mp_t_2_0;
Mp_t_4_0 = Mp_t_3_0 * Mx;
Mp_t_5_0 = Mp_coeff_5 + Mp_t_4_0;
Mp_t_6_0 = Mp_t_5_0 * Mx;
Mp_t_7_0 = Mp_coeff_4 + Mp_t_6_0;
Mp_t_8_0 = Mp_t_7_0 * Mx;
Mp_t_9_0 = Mp_coeff_3 + Mp_t_8_0;
Mp_t_10_0 = Mp_t_9_0 * Mx;
Mp_t_11_0 = Mp_coeff_2 + Mp_t_10_0;
Mp_t_12_0 = Mp_t_11_0 * Mx;
Mp_t_13_0 = Mp_coeff_1 + Mp_t_12_0;
Mp_t_14_0 = Mp_t_13_0 * Mx;
Mp_t_15_0 = Mp_coeff_0 + Mp_t_14_0;
Mp_res = Mp_t_15_0;

# Definition of the relative arithmetical error
epsilon = (p_reshm - Mp_res) / Mp_res;

# Implication to prove
{(
   xhm in [-1b-1,1b-1]
/\ not    xhm in [-1b-401,1b-401]
)
->
(
   epsilon in ?
)}

# Hints and Meta-Hints for expansion decomposition
xh ~ xhm;

p_t_5_0h ~ p_t_5_0hm;
p_t_6_0h ~ p_t_6_0hm;
p_t_7_0h ~ p_t_7_0hm;
p_t_8_0h ~ p_t_8_0hm;
p_t_9_0h ~ p_t_9_0hm;
p_t_10_0h ~ p_t_10_0hm;
p_t_11_0h ~ p_t_11_0hm;
p_t_12_0h ~ p_t_12_0hm;
p_t_13_0h ~ p_t_13_0hm;
p_t_14_0h ~ p_t_14_0hm;
p_t_15_0h ~ p_t_15_0hm;

# Meta-Hints for Horner scheme
p_t_1_0h ~ Mp_t_1_0;
p_t_2_0h ~ Mp_t_2_0;
p_t_3_0h ~ Mp_t_3_0;
p_t_4_0h ~ Mp_t_4_0;
p_t_5_0hm ~ Mp_t_5_0;
p_t_6_0hm ~ Mp_t_6_0;
p_t_7_0hm ~ Mp_t_7_0;
p_t_8_0hm ~ Mp_t_8_0;
p_t_9_0hm ~ Mp_t_9_0;
p_t_10_0hm ~ Mp_t_10_0;
p_t_11_0hm ~ Mp_t_11_0;
p_t_12_0hm ~ Mp_t_12_0;
p_t_13_0hm ~ Mp_t_13_0;
p_t_14_0hm ~ Mp_t_14_0;
p_t_15_0hm ~ Mp_t_15_0;
p_reshm ~ Mp_res;

# Dichotomies for triple-double decomposition

# Dichotomy for the error bound
epsilon $ xhm;


