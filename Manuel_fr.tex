\documentclass[a4paper]{article}

\usepackage[francais]{babel} %typographie tenant compte des spécifités du français
\usepackage{indentfirst} %pour des paragraphes à la française
\usepackage[latin1]{inputenc} %pour une gestion correcte des accents
\usepackage[T1]{fontenc} % pour permettre la césure des mots accentués
\usepackage{lmodern} % pour contrecarrer les effets dégueu de T1 fontenc

\usepackage[naturalnames]{hyperref} % Option naturalnames pour être compatible avec algorithm2e
\usepackage{fullpage}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[mathcal]{eucal}
\usepackage{mathrsfs}
\usepackage{latexsym}
\usepackage{stmaryrd}
\usepackage[all]{xy}
\usepackage{url}
\usepackage[dvips]{graphicx}
\usepackage{xspace}
\usepackage{stmaryrd}

\renewcommand{\epsilon}{\varepsilon}

\newcommand{\punct}[1]{\textrm{\quad #1}}
\newcommand{\tq}{\textrm{ such that\xspace}}
\newcommand{\apriori}{\emph{a priori}\xspace}
\newcommand{\afortiori}{\emph{a fortiori}\xspace}

\newcommand{\N}{\mathbb{N}}

\newcommand{\com}[1]{\texttt{#1}}

\newcommand{\ap}{\com{arenaireplot}\xspace}

\newcommand{\ninf}[1]{\|#1\|_{\infty}}
\newcommand{\eps}{\varepsilon}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\theequation}{\fnsymbol{equation}}


\author{Sylvain~Chevillard \and Christoph~Lauter}
\title{Arenaireplot - Manuel de l'utilisateur}
\begin{document}

\maketitle

\tableofcontents
\newpage


\section{Présentation}
Le logiciel \ap propose une interface unifiée pour un certain nombre
de commandes utilisée lors de l'implémentation logicielle de fonctions
mathématiques. Les fonctionnalités les plus notables sont les
suivantes :
\begin{itemize}
\item une commande \com{plot} équivalente à celle de \com{Maple} mais
  sensible à la précision des calculs. Ceci autorise de tracer une
  fonction de la forme $f-p$ où $f$ et $p$ sont très proches, et ce
  sans que la cancellation du calcul conduise à ne tracer uniquement
  que du bruit ;
\item une commande \com{infnorm} qui calcule la norme infinie d'une
  fonction $f$ sur un intervalle $[a,\,b]$ (c'est-à-dire $\ninf{f} =
  \max \{|f(x)|,\, x\in [a,\,b]\}$). Cette commande existe en deux
  modes : un mode sécurisé qui renvoie un intervalle dans lequel se
  trouve avec certitude la vraie valeur de la norme infinie et un mode
  plus rapide qui renvoie uniquement une valeur approchée de bonne
  qualité de la norme infinie ;
\item une commande \com{remez} qui permet de calculer le polynôme de
  meilleure approximation de degré $n$ d'une fonction $f$ sur un
  intervalle $[a,\,b]$ (c'est-à-dire le polynôme de degré inférieur ou
  égal à $n$ tel que $\ninf{f-p}$ soit minimal) ;
\item une commande \com{integral} qui calcule l'intégrale d'une
  fonction sur un intervalle. Cette commande existe elle aussi en deux
  modes : sécurisé ou rapide.
\item Une commande \com{implementpoly} qui produit du code \texttt{C}
  double précision pour l'évaluation d'un polynôme donné. L'algorithme
  utilisé infère automatiquement les précisions intermédiaires
  nécessaires pour l'évaluation avec une erreur maximale donnée.
\end{itemize}

\section{Compilation}
Pour compiler le logiciel, récupérez la dernière version sur le CVS :

\com{cvs -d:pserver:anonymous@lipforge.ens-lyon.fr:/local/chroot/cvsroot/arenaireplot login}
\com{cvs -z3 -d:pserver:anonymous@lipforge.ens-lyon.fr:/local/chroot/cvsroot/arenaireplot~co~arenaireplot}

\ap nécessite \com{gnuplot}, \com{mpfr} et \com{mpfi} dans des versions récentes, ainsi que \com{pari} dans la version 2.3.0 actuellement disponible dans la distribution testing de Debian.

Faites simplement :
\begin{center}
\com{make}
\end{center}

Nous conseillons d'utiliser le logiciel \com{rlwrap} qui permet de
disposer des fonctionnalités d'édition de la ligne de commande à
l'intérieur d'\com{arenaireplot} :
\begin{center}
\com{rlwrap ./tools}
\end{center}

\section{Description du logiciel}
Le logiciel fonctionne sous la forme d'une console interactive dans laquelle on tape des \com{commandes}. En général, une commande prend en argument une \com{fonction}. Dans \com{arenaireplot}, il ne peut y avoir qu'une seule variable libre tout au long de la session : la première fois que le logiciel rencontre une variable qui n'a pas été précédemment liée, ce nom de variable devient l'identifiant de la variable libre. Le nom devient protégé et on ne peut plus rien lui affecter. L'usage de toute autre variable non précédemment liée déclenchera un warning. La variable en question sera alors interprétée comme la variable libre.

Par la suite, nous noterons $x$ la variable libre, mais n'importe quel nom de variable ne correspondant pas à un mot clé du langage pourrait être utilisé.

\subsection{Liste des fonctions}
\begin{itemize}
\item \com{arenaireplot} reconnaît les constantes \com{pi} et \com{e}
  qui désignent respectivement $\pi$ et l'exponentielle; rencontrés
  dans une expression, il sont remplacés par leur correspondant
  flottant arrondi\footnote{Les expressions \com{e\^~x} et \com{exp(x)}
    sont donc différentes à cause de l'arrondi qui a lieu pour
    \com{e}.} Les nombres peuvent être écrits sous forme habituelle
  (par exemple \com{23.45}), sous forme scientifique (par exemple
  \com{8.21e1} désigne le nombre $82.1$), sous forme binaire
  -- c'est-à-dire sous la forme d'un entier multiplié par une puissance
  entière de $2$ : par exemple \com{3b5} désigne le nombre $3 \cdot
  2^5$ --, sous forme hexadecimale pour les valueur d'une précision
inférieure ou égale à $53$ bits (hexadécimal de la représentation entière en mémoire d'un flottant double précision)
ou bien sous forme binaire comme par exemple $1.1011\_2$.
\item Les fonctions mathématiques les plus usuelles sont reconnues :
  \com{+}, \com{-}, \com{*}, \com{/}, \com{\^} sont infixes et
  désignent l'addition, la soustraction, la multiplication, la
  division et la puissance. La puissance a la précédence sur la
  multiplication et la division, qui ont la précédence sur l'addition
  et la soustraction. Les fonctions préfixes suivantes au nom
  explicite sont reconnues : \com{sqrt}, \com{cos}, \com{sin},
  \com{tan}, \com{acos}, \com{asin}, \com{atan}, \com{exp}, \com{expm1} (la fonction $x \mapsto exp(x)-1$), \com{log}, \com{log1p} (la fonction $x \mapsto log(1+x)$)
  (logarithme népérien), \com{log2} (logarithme en base $2$),
  \com{log10} (logarithme en base $10$), \com{sinh}, \com{cosh},
  \com{tanh}, \com{asinh}, \com{acosh}, \com{atanh}, \com{erf}, \com{erfc}, \com{abs} (la
  valeur absolue). On peut utiliser le signe moins $-$ comme préfixe
  pour la négation.
\item \com{arenaireplot} permet d'arrondir un nombre au double le plus
  proche à l'aide des fonctions préfixes \com{D} ou \com{double} ; au double étendu le plus proche avec \com{doubleextended} ou \com{DE}; au
  double-double le plus proche avec les fonctions \com{DD} ou
  \com{doubledouble} ; au triple-double le plus proche avec les
  fonctions \com{TD} ou \com{tripledouble}. En outre, la fonction \com{round} permet d'arrondir n'importe quel nombre dans un format flottant arbitraire. La syntaxe est \com{round(x, t, mode)} où $x$ est le nombre à arrondir, $t$ est un entier représentant la précision du format visé (par exemple 53 pour de la double) et \com{mode} est l'une des valeurs \com{P}, \com{M}, \com{N} ou \com{Z} indiquant respectivement un arrondi vers $+\infty$, $-\infty$, au plus près ou vers zéro. L'arrondi se fait dans un format idéal, c'est-à-dire sans dépassement de capacité, et donc sans dénormalisé. Ainsi, \com{round(x,53,D)} n'est pas totalement équivalente à \com{D(x)}.
  
\item On peut bien sûr utiliser des parenthèses.
\item \com{arenaireplot} comprend aussi des opérateurs fonctionnels
  (dans la suite \com{expr} désigne une expression fonctionnelle et
  \com{const} désigne une expression s'évaluant en une constante) :
  \begin{itemize}
    \item \com{expand(expr)} : développe toutes les sous-expressions polynômiales de \com{expr}.
    \item \com{horner(expr)} : met sous forme de Horner toutes les sous-expressions polynômiales de \com{expr}.
    \item \com{coeff(expr, n)} : si \com{expr} est un polynôme, renvoie son coefficient de degré n. Renvoie 0 sinon.
    \item \com{taylor(expr, n, const)} : développe \com{expr} sous forme de Taylor à l'ordre $n$ au point \com{const}.
    \item \com{simplify(expr)} : simplifie \com{expr} autant que faire se peut.
    \item \com{simplifysafe(expr)} : idem, mais ne fait pas de simplification lorsque cela imposerait un arrondi.
    \item \com{numerator(expr)} : si \com{expr} est une division, renvoie le numérateur. Sinon, renvoie \com{expr}.
    \item \com{denominator(expr)} : si \com{expr} est une division, renvoie le dénominateur. Sinon, renvoie $1$.
    \item \com{degree(expr)} : si \com{expr} est un polynôme, renvoie son degré. Sinon, renvoie $-1$.
    \item \com{diff(expr)} : dérive formellement \com{expr} en fonction de la variable libre.
    \item \com{substitute(expr1, expr2)} : renvoie une expression dans
      laquelle chaque occurrence de la variable libre de \com{expr1}
      est remplacée par \com{expr2}.
    \item \com{remez(expr, monomes, intervalle)} : renvoie le polynôme
      de meilleure approximation de \com{expr} sur l'intervalle
      \com{intervalle}. Un intervalle est donné sous la forme
      \com{[const; const]} ou bien \com{[const, const]}. \com{monomes}
      peut être un entier (auquel cas il s'agit du degré du polynôme
      visé) ou bien une liste d'entier qui indique les monômes que
      l'on autorise à être non nuls. Ainsi, si \com{monomes =
        [0,2,4,6]}, le polynôme renvoyé sera pair et de degré $6$ au
      plus. On peut utiliser des ellipses de la façon suivante :
      \com{[0, 2...4, 6...8, 10]} désigne la liste de monômes
      \com{[0,~2,~3,~4,~6,~7,~8,~10]}.
    \item \com{subpoly(expr, monomes)} : si \com{expr} est un polynôme, renvoie le sous-polynôme correspondant aux monômes indiqués dans la liste. La liste \com{monomes} vérifie la même syntaxe que pour la fonction \com{remez}. En outre, on peut utiliser une ellipse finale : \com{[0,2,...]} permet de renvoyer le sous-polynôme correspondant au terme constant plus tous les termes à partir du degré 2. Cette fonction renvoie 0 si \com{expr} n'est pas un polynôme.
    \item \com{roundcoefficients(expr, liste)} : si \com{expr} est un polynôme, renvoie le polynôme dont les coefficients ont été arrondis suivant les indications de \com{liste}. \com{liste} est une liste contenant les mots clés \com{D}, \com{double}, \com{DD}, \com{doubledouble}, \com{DE}, \com{doubleextended}, \com{TD}, \com{tripledouble}. Le premier mot clé correspond au monôme de degré 0, le suivant au monôme de degré 1, etc. On peut utiliser une ellipse à la fin de la liste pour signifier que tous les monômes à partir d'un certain rang doivent être arrondis au même format (exemple \com{[DD, DD, D,...]} arrondit les coefficients de degré 0 et 1 au double-double le plus proche, puis tous les autres en double). Si \com{expr} n'est pas un polynôme, un warning est affiché et la valeur renvoyée est \com{expr}.
    \item \com{rationalapprox(const, n)} : renvoie un arbre de la forme $a/b$, où $a$ et $b$ sont des entiers et qui approche \com{const} avec une précision de l'ordre de n bits. Le procédé utilise un développement en fraction continue de façon à ce que la fraction offre le plus petit dénominateur possible. 
    \item \com{fpminimax()} : à venir.
  \end{itemize}
\end{itemize}

\subsection{Liste des commandes}
Chaque commande doit se terminer par un point-virgule.
L'utilisateur peut jouer sur cinq variables globales du logiciel :
\begin{itemize}
\item \com{verbosity = n} : fixe le niveau de précision des messages.
  Par défaut, la valeur est $1$. La valeur $0$ désactive tout
  affichage à part les messages d'erreur. Plus la valeur est grande
  plus les messages sont détaillés.
\item \com{points = n} : fixe le nombre de points à utiliser lors de
  l'usage des commandes \com{plot}, \com{integral} et \com{infnorm}.
  Le nombre minimal de points est $3$. La valeur par défaut est $501$.
  La commande \com{infnorm} est utilisée comme sous-routine par
  d'autres commandes.
\item \com{prec = n} : fixe le nombre de bits à utiliser dans le
  format flottant utilisé par \com{arenaireplot}. La valeur par défaut
  est $165$.
\item \com{dyadic = [on | off | powers | binary]} : active ou
  désactive l'affichage des valeurs en base $2$. Lorsque l'option est
  désactivée (off), l'affichage se fait normalement, c'est-à-dire sous
  forme d'écriture décimale approchée. Lorsque l'option est activée
  (on), toutes les valeurs sont affichées sous la forme binaire
  exacte, correspondant au contenu effectivement stocké en mémoir.
  L'affichage est moins facilement compréhensible, mais ainsi, aucune
  erreur d'arrondi n'est faite lors de l'affichage d'une valeur. On
  peut alors copier-coller sans perte de précision un résultat d'une
  commande à l'intérieur d'une autre commande, par exemple. Lorsque
  l'option est en mode powers, l'affichage se fait sous la forme d'un
  entier divisé par une puissance de 2. Ainsi, la valeur affichée est
  un rationnel et peut être copié exactement dans un outil externe tel
  que Maple, par exemple. Lorsque l'option est en mode binary,
  l'affichage se fait par une mantisse écrite en écriture binaire
  multipliée par la puissance de 2 à l'exposant approprié. La valeur
  par défaut est off.
\item \com{taylorrecursions = n} : fixe le niveau de développement par
  le théorème de Taylor lors d'une évaluation par intervalles d'une
  expression. Plusieurs routines se servent de cette fonction. Il est
  ainsi possible d'influencer sur leur comportement en termes de
  diamètre relatif de l'encadrement calculé. La valeur par défaut est
  $0$, c'est-à-dire la fonction ne recurse pas ce qui correspond à un
  développement linéaire de l'expression donnée. La valeur par défaut est 0.
\item \com{canonical = [on | off]} : lorsque cette option est activée, l'affichage des polynômes se fait sous forme canonique (combinaison linéaire de monômes). Lorsqu'elle est désactivée, l'affichage se fait sous forme de schéma de Hörner. Cela ne concerne que l'affichage d'expressions données directement à l'invite du logiciel (voir plus loin, pour une description de cette fonctionnalité). La valeur par défaut est \com{off}. 
\end{itemize}

Par défaut, ces affectations de variables globales affichent un message pour signaler que la variable globale a bien été mise à jour. Si vous préférez une affectation silencieuse (par exemple parce que la commande sera exécutée dans un script), vous pouvez utiliser un point d'exclamation (exemple \com{prec=23!;}).

Pour connaître la valeur actuelle d'une variable globale, vous pouvez utiliser le point d'interrogation (exemple \com{prec=?;}).

Après que le symbole désignant la variable libre a été fixé, on peut le modifier avec la syntaxe donnée dans l'exemple suivant :
\begin{center}
\begin{tabular}{l}
\com{> print sin(x);}\\
\com{sin(x)}\\
\com{> x = y!;}\\
\com{Warning: the identifier "x" is bound as the current variable. It will be renamed as "y" as forced.}
\end{tabular}
\end{center}

Dans cet exemple, la variable libre est d'abord identifiée à \com{x} (après la première instruction), puis, elle devient identifiée à \com{y} (après la seconde instruction). \com{y} ne doit évidemment pas désigner une variable d'expression déjà affectée.

On peut utiliser des variables pour stocker des expressions. La
commande d'affectation est \com{var = expr} ; la variable ne doit pas
être la variable libre. De la même façon, il
existe une table d'affectations pour intervalles. On peut affecter une
valeur comme suit : \com{var = [a ; b]}. Les portées des variables
d'expressions et d'intervalles sont disjointes; il peut y avoir alors
deux variables ayant le même nom dont l'une remplace une expression et
l'une un intervalle. On ne peut pas réaffecter une variable d'intervalle à l'intérieur d'une autre variable (par exemple, la séquence d'instructions suivante n'est pas permise : \com{a=[-1;1]; b=a;}). L'outil interprète les variables correctement en fonction du contexte. Lorsqu'il y a ambiguïté (par exemple avec la commande print), on doit indiquer explicitement à \com{arenairetools} que l'on souhaite parler d'une variable d'intervalle. Pour ce faire, on l'encadre par des crochets (exemple : \com{a=[-1;1];print [a];}).

Les variables (d'expression ou d'intervalle) peuvent être réaffectées. Lorsqu'une variable déjà affectée est réaffectée, un message d'avertissement est affiché. Pour effectuer une réaffectation sans le message d'avertissement, utilisez la syntaxe \com{a=3!;}

Pour réinitialiser \com{arenairetools}, vous pouvez utiliser la commande \com{restart;} qui a pour effet de libérer toutes les variables affectées (variables d'expression et variables d'intervalle), de remettre les variables globales à leur valeur par défaut, et de désaffecter le nom de la variable libre.


Pour évaluer une fonction, on dispose de la commande \com{evaluate}. Deux syntaxes sont possibles :
\begin{itemize}
\item \com{evaluate expr in intervalle} affiche un intervalle $I$ tel que $\com{expr(intervalle)} \subseteq I$.
\item \com{evaluate expr at const} affiche un intervalle $I$ contenant la valeur exacte de \com{expr(const)}.
\end{itemize}
Cette commande se sert de la routine d'évaluation par théorème de
Taylor et utilise la précision courante pour effectuer ses calculs.

La commande \com{evaluateaccurate expr at const} calcule un arrondi fidèle à la précision courante de la valeur réel de \com{expr} au point \com{const}. Dans le cas où la valeur réelle est trop proche de $0$, \com{arenairetools} peut éventuellement échouer avec un message d'erreur.

Pour afficher une expression, on dispose de la fonction
\com{print}. \com{print expr} affiche simplement la fonction
représentée par \com{expr}. Si \com{expr} contient des opérateurs
fonctionnels, ils sont évalués. En revanche, les fonctions elles-mêmes ne sont pas évaluées et \com{print} affiche juste l'arbre d'expression mémorisé. Par exemple \com{print sin(2)+1;} affiche juste ``sin(2)+1''. On peut aussi déclencher l'affichage
d'une chaîne de caractères via \com{print chaine}. \com{chaine} peut
être n'importe quelle chaîne de caractères respectant la norme
\com{C}. On peut mélanger des expressions et des chaînes de caractères en les séparant par des virgules (exemple \com{print ``La valeur de sin(2.) est'',<evaluate sin(x) at 2>,''.'';}). La commande \com{write} fonctionne comme la commande
\com{print} à la différence près que \com{write} n'affiche pas de retour à la ligne et qu'elle ne met pas d'espace
entre les objets à afficher dont est donné la liste. La commande \com{write} permet de rediriger la sortie
de l'affichage dans un fichier par la syntaxe suivante: \com{write >[>] chaineNomDeFichier listeDObjets} où 
\com{chaineNomDeFichier} est une chaîne de caractères contenant un nom de fichier et où \com{listeDObjets} est
la liste des objets à afficher. Si un chevron est donné (\com{write > ``toto''}), le fichier est nouvellement créé, vidé
et les objets à afficher y sont écrits. Si le nombre de chevrons est deux, le fichier est ouvert en écriture et 
le nouveau affichage est concatené au fichier. 

Lorsqu'une expression est tapée directement à l'invite de \com{arenairetools}, elle est comprise comme un calcul à évaluer puis à afficher. Ainsi, tous les calculs et simplifications qui peuvent être faits sont effectués, puis le résultat est affiché. Pour reprendre l'exemple précédent, si vous tapez \com{sin(2)+1} directement à l'invite, une valeur approchée calculée à la précision courante sera affichée. Vous pouvez bien entendu afficher ainsi des intervalles ou le contenu de variables d'intervalle en utilisant la syntaxe avec des crochets précédemment décrite.

La commande \com{printhexa} permet d'afficher une valeur
double précision sous forme hexadécimale. L'expression donnée est
évaluée avec la précision de l'outil avant qu'un arrondi se fasse vers
la double précision. Un affichage supplémentaire indique s'il y a eu
arrondi ou non.

La commande \com{printbinary} permet d'afficher une valeur quelconque sous forme binaire.

Si \com{expr} désigne un polynôme, la commande \com{printexpansion expr} affiche ce polynôme sous forme de Hörner, où chaque coefficient est affiché sous la forme d'une somme de nombre hexadécimaux correspondant à des doubles. Si \com{expr} n'est pas un polynôme, un warning est affiché et rien ne se passe.

On peut tracer le graphe d'une fonction sur un intervalle de la façon
suivante (les crochets indiquent un paramètre optionnel) :
\begin{center}
\com{plot expr1, expr2, ..., exprn in intervalle [, prec=n] [, points=p], [\emph{commande de sauvegarde}]}
\end{center}
La commande \com{plot} tient compte de la variable globale \com{prec}
pour faire les calculs ([cette option tend à disparaître : son influence réelle sur les calculs est à présent minime]). Si le paramètre optionnel correspondant est
donné, il prend le pas sur la variable globale pendant l'exécution de
la commande. Dans ce cas, la valeur de la variable globale n'est pas modifiée. Il
en est de même pour le paramètre \com{points} qui commande le nombre
de points où la fonction sera évaluée pour le tracé. Le graphique est
fidèle au sens où, en chaque point où la fonction a été échantillonnée,
la valeur calculée de la fonction est un arrondi fidèle de la véritable
valeur dans le format double. Une liste d'expressions peut être donnée
auquel cas les fonctions seront toutes affichées sur le même graphique.
Les commandes de sauvegarde sont les suivantes (une seule peut être 
utilisée à la fois) :
\begin{itemize}
  \item \com{file=filename} : les fichiers de données et d'instructions
    gnuplot sont sauvegardé dans les fichiers \texttt{filename.dat} et
    \texttt{filename.p}. Le graphique est affiché à l'écran.
  \item \com{postscript=filename} : le graphique n'est pas affiché mais
    est sauvegardé dans le fichier \texttt{filename.eps}.
  \item \com{postscriptfile=filename} : le graphique n'est pas affiché
    mais est sauvegardé dans le fichier \texttt{filename.eps}. En outre
    les fichiers de données et d'instructions gnuplot correspondants
    sont enregistrés dans les fichiers  \texttt{filename.dat} et
    \texttt{filename.p}
\end{itemize}

Il peut être utile parfois de tracer le graphe correspondant à l'erreur d'évaluation faite par un bout de code. Il existe pour cela la commande \com{externalplot}. La syntaxe est la suivante :

\begin{center}
\com{externalplot chaine \emph{mode} to expr in intervalle with n bits [,perturb] [\emph{commande de sauvegarde}]}
\end{center}
\emph{mode} peut prendre la valeur \com{absolute} ou \com{relative} suivant le type d'erreur que l'on souhaite afficher. Les commandes de sauvegarde sont les mêmes que pour la commande \com{plot}. \com{chaine} est une chaîne de caractères représentant un chemin d'accès vers une librairie dynamique (par exemple ``./monProg''). Cette librairie doit contenir une fonction appelée \com{f} et dont la signature est \com{void f(mpfr\_t result, mpfr\_t x)}.

La commande procède ainsi : elle utilise un format de nombre flottant sur \com{n} bits (où \com{n} est le paramètre passé à la fonction \com{externalplot}). Avec ce format, elle avance d'un ulp en un ulp en partant de la borne gauche de l'intervalle et évalue en chaque point \com{expr-f} ou \com{expr/f-1} suivant le mode choisi. La fonction \com{f} est donc appelée avec la valeur corresondante stockée dans \com{x}. Le point \com{(x, expr-f)} est ajouté au graphe. Si l'intervalle donné comprend $0$, la commande ignore les points tellement proche de $0$ qu'ils ne seraient pas visible sur le graphe. Le graphe affiché correspond donc à tous les nombres flottants sur \com{n} bits dans un ensemble de la forme $(I \backslash [-a;a]) \cup \{0\}$ où $a$ est déterminé par \com{externalplot} en fonction de $I$.

Si l'option \com{perturb} est donnée, la commande ne fait pas exactement le calcul d'erreur sur les flottants d'un format \com{n} bits. En réalité, \com{externalplot} se déplace alors effectivement de un ulp à chaque fois, mais le point où l'erreur va être calculée est ensuite aléatoirement légèrement perturbé. Ainsi, on ne risque pas d'observer des régularités fantômes dues à la régularité des points d'échantillonnage.

La commande \com{guessdegree} permet de déterminer le degré nécessaire pour qu'un polynôme approche une fonction à une précision donnée. Cette commande procède par dichotomie en testant différent degrés jusqu'à trouver un degré satisfaisant. Comme il s'agit simplement d'un indicateur, la commande ne calcule pas précisément des minimax, mais elle en calcule une estimation pour connaître l'ordre de grandeur de l'erreur optimale associée à un degré $n$. Il peut donc arriver que la commande ne sâche pas déterminer si un certain degré sera suffisant ou non car son estimation n'est pas assez précise.  Par conséquent, il y a deux retours possibles : ou bien la commande donne effectivement le degré adapté, et dans ce cas, ce degré est effectivement optimal ; ou bien la commande donne un intervalle $[n_1,\,n2]$ tel que $n_1$ est la plus petite valeur pour laquelle il y a hésitation et $n_2$ est la plus petite valeur pour laquelle on est sûr que la précision sera atteinte. En général, on aura $n_2 = n_1 + 1$. La syntaxe est la suivante :
\begin{center}
\com{guessdegree expr1 in range with epsilon=const [, weight=expr2]}
\end{center}
La fonction à approcher est \com{expr1} en utilisant le cas échéant la fonction de poids \com{expr2} (i.e. on cherche à approcher \com{expr1} par une fonction de la forme \com{expr2} fois un polynôme). L'intervalle considéré est \com{range} et l'erreur visée est l'expression constante \com{const}.

La commande \com{findzeros} permet de lister les zéros d'une fonction
sur un intervalle. Plus précisément, la syntaxe est la suivante (les
crochets indiquent un paramètre optionnel) :
\begin{center}
\com{findzeros expr in intervalle [, diam=const]}
\end{center}
Cette commande affiche une liste d'intervalles tels que chaque zero de
\com{expr} est dans l'un des intervalles. Il faut noter que la liste
d'intervalles peut contenir des intervalles dans lesquels il n'y a pas
de zéro ; de même un intervalle de la liste peut contenir plusieurs
zéros. La variable globale \com{diam} fixe la taille relative des
intervalles au-delà de laquelle la commande n'essaie plus de
discriminer des zéros. Si le paramètre optionnel \com{diam} est passé
à la commande, il prend le pas sur le variable globale pour
l'exécution de la commande. Le paramètre global reste inchangé.

La commande \com{fpfindzeros} est un raffinement autour de \com{findzeros}. La syntaxe est la même que pour \com{findzeros}, sans le paramètre optionnel \com{diam}. Les résultats ne sont pas garantis (la commande peut oublier de lister des zéros, ou lister des points qui ne sont pas des zéros) mais sont satisfaisant des les cas pratiques pas trop complexes. La commande renvoie une liste ordonnée de nombre à la précision courante, qui approchent assez bien les vrais zéros de la fonction.

La commande \com{zerodenominators expr in intervalle} applique la commande \com{fpfindzeros} à toutes les sous-expressions de \com{expr} qui sont le dénominateur d'une division.

La commande \com{worstcase} permet de détecter les pires cas d'une
fonction vis-à-vis du dilemme du fabricant de tables. La syntaxe est
la suivante (les crochets indiquent un paramètre optionnel) :

\begin{center}
\com{worstcase expr with inputprec=n, inputexpo=[p,q], outputprec=r, epsilon=const [,output=filename]}
\end{center}

Pour la fonction $f$ donnée par l'expression \com{expr}, cette
commande affiche la liste de tous les flottants sur $n$ bits avec un
exposant entre $p$ et $q$, c'est-à-dire $x = 2^E \cdot m$, $E \in
\left[ p ; q \right] \cap \N$, $m \cdot 2^n \in \left[ 2^n ; 2^{n+1} -
  1 \right] \cap \N$, dont les images par $f$, arrondies vers un
format flottant sur $r$ bits sont relativement plus proches de la
valeur réelle de $f(x)$ que le paramètre $\epsilon=$\com{const} donné.
Formellement, ces valeurs images satisfont $y = 2^F \cdot t =
\circ\left( f\left( x \right) \right)$, $F \in \N$, $t \cdot 2^r \in
\left[ 2^r ; 2^{r+1} - 1 \right] \cap \N$ et  $\left \vert \frac{y
    - f(x)}{f(x)} \right \vert \leq \epsilon$.


La commande \com{searchgal} permet de trouver un point flottant tel que pour toute fonction
de celles données dans une liste, l'arrondi de l'image de la fonction ne soit éloigné de la fonction
que d'une erreur relative spécifiée. La syntaxe de la commande est la suivante:

\begin{center}
\com{searchgal listeDeFonctions at pointDeDepart with nombreDeBitsPreimage bits in entier steps in listeDArrondis with epsilon = listeDeConstantes }
\end{center}

Ici \com{listeDeFonctions} est la liste d'expressions représentant des
fonctions, \com{nombreDeBitsPreimage} est le nombre de bits du format
flottant dans lequel le point est recherché, \com{entier} est le
logarithme en base $2$ du nombre de pas de calcul à faire pendant la
recherche, \com{listeDArrondis} est la liste des operateurs arrondis
(c'est-à-dire l'arrondi double \com{D}, l'arrondi double-double
\com{DD}, l'arrondi triple-double \com{TD}, l'arrondi double-étendue
\com{DE}) associés aux fonctions données et \com{listeDeConstantes} est 
la liste des erreurs relatives maximales autorisées.

\com{arenaireplot} comprend deux commandes pour calculer la norme
infinie d'une fonction : l'une est sûre mais un peu lente ; l'autre
est rapide mais ne fournit pas de garantie.
\begin{itemize}
\item \com{dirtyinfnorm expr in intervalle [,points=n]} est la version
  rapide. Elle affiche une valeur approchée de la norme infinie de
  \com{expr}. Le paramètre optionnel permet de passer outre la
  variable globale \com{points}. L'algorithme utilisé par cette
  commande consiste simplement à calculer des valeurs approchées de la
  fonction en de nombreux points de l'intervalle et à considérer le
  maximum en valeur absolue. En outre, dans la mesure du possible, les extrema locaux de la fonctions sont déterminés de façon approchée au cours de l'algorithme et sont inclus dans l'ensemble des points d'échantillonnage. Ainsi, pour des fonctions raisonnablement simples, cette commande renvoie une valeur très fiable de la norme infinie. La variable \com{points} fixe le nombre
  de points utilisés.
\item \com{infnorm expr in intervalle [without intervalle1,
    intervalle2, \dots , intervallek] [,diam = const]
    [,proof=filename]} est la version certifiée. Les paramètres
  optionnels permettent les choses suivantes :
  \begin{itemize}
  \item \com{without} permet d'exclure une liste d'intervalles de la
    recherche. Ce paramètre est utile lorsqu'on constate que la
    commande échoue à donner une borne précise à cause d'un ou
    plusieurs points particuliers (généralement des faux-pôles, ou des
    points de grande cancellation). On peut ainsi les exclure et faire
    une analyse manuellement sur les intervalles exclus.
    \item \com{diam} permet de passer outre la valeur de la variable globale correspondante.
    \item \com{proof} permet de sauvegarder dans un fichier une preuve en anglais de la correction de la borne renvoyée.
    \end{itemize}
    La commande \com{infnorm} affiche un majorant de la norme infinie
    ainsi qu'un indice de confiance (en d'autres termes,
    il s'agit d'un intervalle contenant la valeur exacte de la norme
    infinie).
\end{itemize}

\com{arenaireplot} comprend deux commandes pour calculer l'intégrale
d'une fonction : l'une est sûre mais un peu lente ; l'autre est rapide
mais ne fournit pas de garantie.
\begin{itemize}
\item \com{dirtyintegral expr in intervalle [,points=n]} est la
  version rapide. Elle affiche une valeur approchée de l'intégrale de
  \com{expr}. Le paramètre optionnel permet de passer outre la
  variable globale \com{points}. L'algorithme utilisé par cette
  commande est la méthode des trapèzes. La variable \com{points} fixe
  le nombre de points utilisée.
\item \com{integral expr in intervalle [,points=n]} est la version
  certifiée. L'algorithme est le même mais en utilisant des
  évaluations par intervalles.

  La commande \com{integral} affiche un majorant de l'intégrale ainsi
  qu'un indice de confiance (en d'autres termes, il
  s'agit d'un intervalle contenant la valeur exacte de l'intégrale).
\end{itemize}

\com{arenaireplot} permet de vérifier d'une façon sure qu'une valeur
borne la norme infinie d'une fonction dans un intervalle. La commande correspondante est la suivante : 
\begin{center}
\com{checkinfnorm expr in intervalle bounded by const [, diam = const ]}
\end{center}
La commande vérifie par évaluation en arithmétique d'intervalle et
dichotomie que la fonction donnée par l'expression \com{expr} dans
l'intervalle \com{intervalle} est bornée en valeur absolue par
\com{const}. Le paramètre \com{diam}, si donné, prend le dessus sur la
variable globale correspondante sans la modifier. Pour cette
procédure, il indique la taille relative des intervalles pour lesquels
la verification échoue si la borne ne peut être vérifiée.

L'outil \com{arenaireplot} peut aussi être une aide pour
l'implémentation en double, double-double et triple-double précision
d'un polynôme donné. La commande correspondante est la suivante:
\begin{center}
  \com{implementpoly expr in intervalle with epsilon = const with
    variable as format in fichier with name = chaine [, honorcoeffprec ]}
\end{center}

Cette commande implémente dans le fichier \com{fichier} une fonction
\texttt{C} s'appelant \com{chaine} prenant en paramètre - dépendamment
de \com{format} qui peut être un des mot-clefs \com{double},
\com{doubledouble} ou \com{tripledouble} - une, deux ou trois nombres
double précision nommés comme la variable libre de l'expression
\com{expr} (avec - au besoin - un suffixe \com{h}, \com{m} ou \com{l})
et un, deux ou trois pointeurs sur des variables double precision
indiquant les endroits mémoire où le résultat de l'évaluation sera à
stocker. Cette fonction permettra d'évaluer le polynôme donné par
\com{expr} dans l'intervalle \com{intervalle} d'une façon telle que
l'erreur d'arrondi relative sera de l'ordre de \com{const}. Le
polynôme implémenté peut mathématiquement différer du polynôme donné.
Dans ce cas, un avertissement sera affiché. L'algorithme d'évaluation
utilisé est le schema de Horner avec un précalcul des puissances
nécessaires si quelques coefficients du polynôme sont $0$. Pour que
l'implémentation réussisse, le polynôme doit satisfaire certaines
conditions, en particulier pour aucune valeur dans l'intervalle
\com{intervalle} et pour aucune étape de Horner aucune cancellation ne
devra avoir lieu. La procédure d'implémentation vérifie ces conditions
aussi précisement que possible. Le paramètre global \com{points} a une
certaine influence sur cette procédure parce que celle-ci utilise le
calcul d'une norme infinie ainsi paramétré comme sous-fonction.

Enfin la commande \com{bashexecute chaine} interprète la chaîne de caractères dans un shell, ce qui permet d'exécuter, à l'intérieur de \com{arenairetools}, des commandes externes (exemple \com{bashexecute ``cvs up''} met à jour les sources du logiciel, à l'intérieur même de \com{arenairetools}).

Pour quitter \com{arenaireplot}, il suffit d'utiliser la commande
\com{quit}. On peut aussi utiliser les raccourcis \com{control+D} ou
\com{control+C}.

\subsection{Astuces}
Les commandes ne renvoient pas de valeur : elles se contentent de
changer l'état interne du logiciel ou encore d'afficher un résultat
sur la sortie standard. Dans le cas où la commande affiche un
résultat, on peut vouloir réutiliser ce résultat par la suite.
\com{arenaireplot} fournit donc une astuce pour transformer une
commande en fonction lorque ça a un sens. Si \com{commande} désigne
une commande ayant pour effet d'afficher un résultat sous forme d'un
nombre ou d'un intervalle, on peut utiliser au sein d'une expression
les expressions suivantes :
\begin{itemize}
\item \com{<[commande]>} renvoie l'intervalle qu'afficherait la commande \com{commande}.
\item \com{<commande>} renvoie la borne supérieure de l'intervalle qu'afficherait la commande \com{commande}. Dans ce cas, \com{commande} peut simplement être un nom de variable d'intervalle.
\item \com{<commande>.} renvoie le milieu de l'intervalle qu'afficherait la commande \com{commande}. Même remarque que pour le point précédent.
\item \com{<commande>\_} renvoie la borne inférieure de l'intervalle qu'afficherait la commande \com{commande}. Même remarque.
\end{itemize}
De manière générale, si \com{commande} désigne une commande qui affiche un résultat qu'il est raisonnable de stocker dans une variable (un intervalle, une expression, une valeur), on peut utiliser au sein d'une expression l'expression \com{<commande>} qui désigne le résultat de cette commande.

Cas un peu spécial : on peut obtenir le polynôme effectivement implémenté par \com{implementpoly} en utilisant cette syntaxe.

En outre, si \com{var} désigne une variable à laquelle on a affecté une expression \com{expr1}, la notation \com{var(expr2)} est équivalente à \com{substitute(expr1,expr2)}. 
\end{document}
